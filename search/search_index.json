{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"t3api-utils","text":"<p>Python utilities for the T3 (Track and Trace Tools) API.</p> <p>Provides authentication, data collection, processing, and export tools for working with Metrc cannabis regulatory data through the T3 API.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>uv pip install t3api-utils\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from t3api_utils.main.utils import get_authenticated_client_or_error\nfrom t3api_utils.api.operations import get_collection\n\n# Authenticate (interactive picker for credentials, JWT, or API key)\nclient = get_authenticated_client_or_error()\n\n# Fetch a paginated collection\nresponse = get_collection(client, \"/v2/packages\", license_number=\"LIC-0001\")\n</code></pre>"},{"location":"#package-overview","title":"Package Overview","text":"Module Description <code>api</code> httpx-based API client with async support and paginated collection fetching <code>auth</code> Authentication utilities for credentials, JWT, and API key flows <code>http</code> Low-level httpx client construction with retry policies and rate limiting <code>db</code> DuckDB-backed data flattening, table creation, and schema export <code>file</code> CSV/JSON serialization and file output utilities <code>collection</code> Parallel data loading and extraction helpers <code>openapi</code> OpenAPI spec fetching and interactive endpoint selection <code>cli</code> CLI configuration management and interactive credential prompting <code>style</code> Rich console theming and styled message helpers <code>inspector</code> Textual TUI for interactive collection browsing"},{"location":"#data-flow","title":"Data Flow","text":"<ol> <li>Authentication (<code>auth</code>) - Create authenticated httpx-based API clients</li> <li>Collection (<code>api</code>) - Parallel data fetching with rate limiting</li> <li>Processing (<code>db</code>) - Flatten nested data and create relational tables</li> <li>Output (<code>file</code>) - Export to CSV/JSON formats</li> </ol>"},{"location":"reference/api-client/","title":"API Client","text":""},{"location":"reference/api-client/#t3api_utils.api.client","title":"client","text":"<p>T3 API client built on httpx.</p> <p>Provides :class:<code>T3APIClient</code>, an async httpx-based client that handles authentication, retries, and response parsing for the T3 API.</p>"},{"location":"reference/api-client/#t3api_utils.api.client.T3APIClient","title":"T3APIClient","text":"<pre><code>T3APIClient(*, config: Optional[HTTPConfig] = None, retry_policy: Optional[RetryPolicy] = None, logging_hooks: Optional[LoggingHooks] = None, headers: Optional[Dict[str, str]] = None)\n</code></pre> <p>Async T3 API client using httpx.AsyncClient.</p> <p>This client provides a high-level interface to the T3 API, handling authentication, retries, and response parsing with async/await support for better performance when making many concurrent requests.</p> <p>Initialize the async T3 API client.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Optional[HTTPConfig]</code> <p>HTTP configuration (host, timeout, etc.)</p> <code>None</code> <code>retry_policy</code> <code>Optional[RetryPolicy]</code> <p>Retry policy for failed requests</p> <code>None</code> <code>logging_hooks</code> <code>Optional[LoggingHooks]</code> <p>Optional request/response logging</p> <code>None</code> <code>headers</code> <code>Optional[Dict[str, str]]</code> <p>Additional headers to include with requests</p> <code>None</code> Source code in <code>t3api_utils/api/client.py</code> <pre><code>def __init__(\n    self,\n    *,\n    config: Optional[HTTPConfig] = None,\n    retry_policy: Optional[RetryPolicy] = None,\n    logging_hooks: Optional[LoggingHooks] = None,\n    headers: Optional[Dict[str, str]] = None,\n) -&gt; None:\n    \"\"\"Initialize the async T3 API client.\n\n    Args:\n        config: HTTP configuration (host, timeout, etc.)\n        retry_policy: Retry policy for failed requests\n        logging_hooks: Optional request/response logging\n        headers: Additional headers to include with requests\n    \"\"\"\n    self._config = config or HTTPConfig()\n    self._retry_policy = retry_policy or RetryPolicy()\n    self._logging_hooks = logging_hooks\n    self._extra_headers = headers or {}\n\n    # Build the async httpx client\n    self._client = build_async_client(\n        config=self._config,\n        headers=self._extra_headers,\n        hooks=self._logging_hooks,\n    )\n\n    # Track authentication state\n    self._authenticated = False\n    self._access_token: Optional[str] = None\n</code></pre>"},{"location":"reference/api-client/#t3api_utils.api.client.T3APIClient.is_authenticated","title":"is_authenticated  <code>property</code>","text":"<pre><code>is_authenticated: bool\n</code></pre> <p>Check if client is authenticated.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if an access token has been set and authentication succeeded.</p>"},{"location":"reference/api-client/#t3api_utils.api.client.T3APIClient.access_token","title":"access_token  <code>property</code>","text":"<pre><code>access_token: Optional[str]\n</code></pre> <p>Get the current access token.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The JWT bearer token string, or <code>None</code> if unauthenticated.</p>"},{"location":"reference/api-client/#t3api_utils.api.client.T3APIClient.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; T3APIClient\n</code></pre> <p>Async context manager entry.</p> Source code in <code>t3api_utils/api/client.py</code> <pre><code>async def __aenter__(self) -&gt; T3APIClient:\n    \"\"\"Async context manager entry.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/api-client/#t3api_utils.api.client.T3APIClient.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(exc_type: object, exc_val: object, exc_tb: object) -&gt; None\n</code></pre> <p>Async context manager exit.</p> Source code in <code>t3api_utils/api/client.py</code> <pre><code>async def __aexit__(self, exc_type: object, exc_val: object, exc_tb: object) -&gt; None:\n    \"\"\"Async context manager exit.\"\"\"\n    await self.close()\n</code></pre>"},{"location":"reference/api-client/#t3api_utils.api.client.T3APIClient.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the underlying HTTP client.</p> Source code in <code>t3api_utils/api/client.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the underlying HTTP client.\"\"\"\n    await self._client.aclose()\n</code></pre>"},{"location":"reference/api-client/#t3api_utils.api.client.T3APIClient.set_access_token","title":"set_access_token","text":"<pre><code>set_access_token(token: str) -&gt; None\n</code></pre> <p>Set the access token for authentication.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Bearer token for API authentication</p> required Source code in <code>t3api_utils/api/client.py</code> <pre><code>def set_access_token(self, token: str) -&gt; None:\n    \"\"\"Set the access token for authentication.\n\n    Args:\n        token: Bearer token for API authentication\n    \"\"\"\n    self._access_token = token\n    set_bearer_token(client=self._client, token=token)\n    self._authenticated = True\n</code></pre>"},{"location":"reference/api-client/#t3api_utils.api.client.T3APIClient.clear_access_token","title":"clear_access_token","text":"<pre><code>clear_access_token() -&gt; None\n</code></pre> <p>Clear the access token and mark the client as unauthenticated.</p> <p>Removes the <code>Authorization</code> header from the underlying httpx client.</p> Source code in <code>t3api_utils/api/client.py</code> <pre><code>def clear_access_token(self) -&gt; None:\n    \"\"\"Clear the access token and mark the client as unauthenticated.\n\n    Removes the ``Authorization`` header from the underlying httpx client.\n    \"\"\"\n    self._access_token = None\n    clear_bearer_token(client=self._client)\n    self._authenticated = False\n</code></pre>"},{"location":"reference/api-client/#t3api_utils.api.client.T3APIClient.authenticate_with_credentials","title":"authenticate_with_credentials  <code>async</code>","text":"<pre><code>authenticate_with_credentials(*, hostname: str, username: str, password: str, otp: Optional[str] = None, email: Optional[str] = None) -&gt; AuthResponseData\n</code></pre> <p>Authenticate with T3 API using credentials.</p> <p>Parameters:</p> Name Type Description Default <code>hostname</code> <code>str</code> <p>The hostname for authentication</p> required <code>username</code> <code>str</code> <p>Username</p> required <code>password</code> <code>str</code> <p>Password</p> required <code>otp</code> <code>Optional[str]</code> <p>Optional one-time password</p> <code>None</code> <code>email</code> <code>Optional[str]</code> <p>Optional email address</p> <code>None</code> <p>Returns:</p> Type Description <code>AuthResponseData</code> <p>AuthResponseData containing access token and metadata</p> <p>Raises:</p> Type Description <code>T3HTTPError</code> <p>If authentication fails</p> Source code in <code>t3api_utils/api/client.py</code> <pre><code>async def authenticate_with_credentials(\n    self,\n    *,\n    hostname: str,\n    username: str,\n    password: str,\n    otp: Optional[str] = None,\n    email: Optional[str] = None,\n) -&gt; AuthResponseData:\n    \"\"\"Authenticate with T3 API using credentials.\n\n    Args:\n        hostname: The hostname for authentication\n        username: Username\n        password: Password\n        otp: Optional one-time password\n        email: Optional email address\n\n    Returns:\n        AuthResponseData containing access token and metadata\n\n    Raises:\n        T3HTTPError: If authentication fails\n    \"\"\"\n    # Prepare request payload\n    payload = {\n        \"hostname\": hostname,\n        \"username\": username,\n        \"password\": password,\n    }\n\n    if otp is not None:\n        payload[\"otp\"] = otp\n\n    if email is not None:\n        payload[\"email\"] = email\n\n    # Make the request\n    try:\n        response_data = await arequest_json(\n            aclient=self._client,\n            method=\"POST\",\n            url=\"/v2/auth/credentials\",\n            json_body=payload,\n            policy=self._retry_policy,\n            expected_status=200,\n        )\n\n        # Set the token for future requests\n        self.set_access_token(response_data[\"accessToken\"])\n\n        return cast(AuthResponseData, response_data)\n\n    except T3HTTPError as e:\n        # Re-raise with more context\n        raise T3HTTPError(f\"Authentication failed: {e}\", response=e.response) from e\n</code></pre>"},{"location":"reference/api-client/#t3api_utils.api.client.T3APIClient.authenticate_with_api_key","title":"authenticate_with_api_key  <code>async</code>","text":"<pre><code>authenticate_with_api_key(*, api_key: str, state_code: str) -&gt; AuthResponseData\n</code></pre> <p>Authenticate with T3 API using API key.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>API key for the T3 API</p> required <code>state_code</code> <code>str</code> <p>State code (e.g., \"CA\", \"MO\", \"CO\", \"MI\")</p> required <p>Returns:</p> Type Description <code>AuthResponseData</code> <p>AuthResponseData containing access token and metadata</p> <p>Raises:</p> Type Description <code>T3HTTPError</code> <p>If authentication fails</p> Source code in <code>t3api_utils/api/client.py</code> <pre><code>async def authenticate_with_api_key(\n    self,\n    *,\n    api_key: str,\n    state_code: str,\n) -&gt; AuthResponseData:\n    \"\"\"Authenticate with T3 API using API key.\n\n    Args:\n        api_key: API key for the T3 API\n        state_code: State code (e.g., \"CA\", \"MO\", \"CO\", \"MI\")\n\n    Returns:\n        AuthResponseData containing access token and metadata\n\n    Raises:\n        T3HTTPError: If authentication fails\n    \"\"\"\n    # Prepare request payload\n    payload = {\n        \"apiKey\": api_key,\n        \"stateCode\": state_code,\n    }\n\n    # Make the request\n    try:\n        response_data = await arequest_json(\n            aclient=self._client,\n            method=\"POST\",\n            url=\"/v2/auth/apikey\",\n            json_body=payload,\n            policy=self._retry_policy,\n            expected_status=200,\n        )\n\n        # Set the token for future requests\n        self.set_access_token(response_data[\"accessToken\"])\n\n        return cast(AuthResponseData, response_data)\n\n    except T3HTTPError as e:\n        # Re-raise with more context\n        raise T3HTTPError(f\"API key authentication failed: {e}\", response=e.response) from e\n</code></pre>"},{"location":"reference/api-operations/","title":"API Operations","text":""},{"location":"reference/api-operations/#t3api_utils.api.operations","title":"operations","text":"<p>Standalone T3 API operations that work with authenticated clients.</p> <p>This module provides high-level operations for T3 API endpoints that can be called independently with an authenticated client instance.</p> <p>Available operations: - send_api_request / send_api_request_async: Most generic operation, supports any HTTP method,   custom parameters, and doesn't assume response structure - get_collection / get_collection_async: Specialized for paginated collection   endpoints, automatically adds page/pageSize parameters</p>"},{"location":"reference/api-operations/#t3api_utils.api.operations.send_api_request","title":"send_api_request","text":"<pre><code>send_api_request(client: T3APIClient, path: str, *, method: str = 'GET', params: Optional[Dict[str, Any]] = None, json_body: Optional[Any] = None, headers: Optional[Dict[str, str]] = None, expected_status: Union[int, tuple[int, ...]] = 200) -&gt; Any\n</code></pre> <p>Send a request to any T3 API endpoint (sync wrapper).</p> <p>This is the most flexible operation that doesn't assume any specific parameter structure or response format.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>T3APIClient</code> <p>Authenticated T3APIClient instance</p> required <code>path</code> <code>str</code> <p>API endpoint path (e.g., \"/v2/licenses\", \"/v2/packages/active\", \"/v2/facilities/123\")</p> required <code>method</code> <code>str</code> <p>HTTP method (default: \"GET\")</p> <code>'GET'</code> <code>params</code> <code>Optional[Dict[str, Any]]</code> <p>Query parameters (optional)</p> <code>None</code> <code>json_body</code> <code>Optional[Any]</code> <p>JSON request body for POST/PUT requests (optional)</p> <code>None</code> <code>headers</code> <code>Optional[Dict[str, str]]</code> <p>Additional headers (optional)</p> <code>None</code> <code>expected_status</code> <code>Union[int, tuple[int, ...]]</code> <p>Expected HTTP status code(s) (default: 200)</p> <code>200</code> <p>Returns:</p> Type Description <code>Any</code> <p>Raw response data (could be dict, list, or any JSON-serializable type)</p> <p>Raises:</p> Type Description <code>T3HTTPError</code> <p>If request fails or client not authenticated</p> Source code in <code>t3api_utils/api/operations.py</code> <pre><code>def send_api_request(\n    client: T3APIClient,\n    path: str,\n    *,\n    method: str = \"GET\",\n    params: Optional[Dict[str, Any]] = None,\n    json_body: Optional[Any] = None,\n    headers: Optional[Dict[str, str]] = None,\n    expected_status: Union[int, tuple[int, ...]] = 200,\n) -&gt; Any:\n    \"\"\"Send a request to any T3 API endpoint (sync wrapper).\n\n    This is the most flexible operation that doesn't assume any specific\n    parameter structure or response format.\n\n    Args:\n        client: Authenticated T3APIClient instance\n        path: API endpoint path (e.g., \"/v2/licenses\", \"/v2/packages/active\", \"/v2/facilities/123\")\n        method: HTTP method (default: \"GET\")\n        params: Query parameters (optional)\n        json_body: JSON request body for POST/PUT requests (optional)\n        headers: Additional headers (optional)\n        expected_status: Expected HTTP status code(s) (default: 200)\n\n    Returns:\n        Raw response data (could be dict, list, or any JSON-serializable type)\n\n    Raises:\n        T3HTTPError: If request fails or client not authenticated\n    \"\"\"\n    # For sync wrapper, we need to handle the case where the client might have been\n    # created in a different event loop context. The safest approach is to create\n    # a new client instance for this operation.\n\n    from t3api_utils.http.utils import request_json\n\n    # Use the sync version of request_json directly with the client's underlying config\n    if not client.is_authenticated:\n        raise T3HTTPError(\"Client is not authenticated. Call authenticate_with_credentials() first.\")\n\n    # Extract auth headers from the async client\n    headers_dict = dict(headers) if headers else {}\n    if client.access_token:\n        headers_dict[\"Authorization\"] = f\"Bearer {client.access_token}\"\n\n    # Create a sync httpx client for this operation\n    import httpx\n\n    # Prepare client kwargs, handling optional parameters properly\n    client_kwargs: Dict[str, Any] = {\n        \"base_url\": client._config.host,\n        \"timeout\": client._config.timeout,\n        \"verify\": client._config.ssl_context,\n    }\n\n    if client._config.base_headers:\n        client_kwargs[\"headers\"] = client._config.base_headers\n\n    if client._config.proxies:\n        client_kwargs[\"proxies\"] = client._config.proxies\n\n    with httpx.Client(**client_kwargs) as sync_client:\n        return request_json(\n            client=sync_client,\n            method=method,\n            url=path,\n            params=params,\n            json_body=json_body,\n            headers=headers_dict,\n            policy=client._retry_policy,\n            expected_status=expected_status,\n        )\n</code></pre>"},{"location":"reference/api-operations/#t3api_utils.api.operations.get_collection","title":"get_collection","text":"<pre><code>get_collection(client: T3APIClient, path: str, *, license_number: str, page: int = 1, page_size: int = 100, strict_pagination: bool = False, sort: Optional[str] = None, filter_logic: Literal['and', 'or'] = 'and', filter: Optional[List[str]] = None, **kwargs: Any) -&gt; MetrcCollectionResponse\n</code></pre> <p>Get a collection from any T3 API endpoint (sync wrapper).</p> <p>This is a wrapper around the async implementation using asyncio.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>T3APIClient</code> <p>Authenticated T3APIClient instance</p> required <code>path</code> <code>str</code> <p>API endpoint path (e.g., \"/v2/licenses\", \"/v2/packages/active\")</p> required <code>license_number</code> <code>str</code> <p>The unique identifier for the license (required)</p> required <code>page</code> <code>int</code> <p>Page number (1-based, default: 1)</p> <code>1</code> <code>page_size</code> <code>int</code> <p>Number of items per page (default: 100)</p> <code>100</code> <code>strict_pagination</code> <code>bool</code> <p>If enabled, out of bounds pages throw 400 (default: False)</p> <code>False</code> <code>sort</code> <code>Optional[str]</code> <p>Collection sort order (e.g., \"label:asc\")</p> <code>None</code> <code>filter_logic</code> <code>Literal['and', 'or']</code> <p>How filters are applied - \"and\" or \"or\" (default: \"and\")</p> <code>'and'</code> <code>filter</code> <code>Optional[List[str]]</code> <p>List of collection filters (e.g., [\"label__endswith:0003\"])</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional query parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>MetrcCollectionResponse</code> <p>MetrcCollectionResponse containing data from the endpoint</p> <p>Raises:</p> Type Description <code>T3HTTPError</code> <p>If request fails or client not authenticated</p> Source code in <code>t3api_utils/api/operations.py</code> <pre><code>def get_collection(\n    client: T3APIClient,\n    path: str,\n    *,\n    license_number: str,\n    page: int = 1,\n    page_size: int = 100,\n    strict_pagination: bool = False,\n    sort: Optional[str] = None,\n    filter_logic: Literal[\"and\", \"or\"] = \"and\",\n    filter: Optional[List[str]] = None,\n    **kwargs: Any,\n) -&gt; MetrcCollectionResponse:\n    \"\"\"Get a collection from any T3 API endpoint (sync wrapper).\n\n    This is a wrapper around the async implementation using asyncio.\n\n    Args:\n        client: Authenticated T3APIClient instance\n        path: API endpoint path (e.g., \"/v2/licenses\", \"/v2/packages/active\")\n        license_number: The unique identifier for the license (required)\n        page: Page number (1-based, default: 1)\n        page_size: Number of items per page (default: 100)\n        strict_pagination: If enabled, out of bounds pages throw 400 (default: False)\n        sort: Collection sort order (e.g., \"label:asc\")\n        filter_logic: How filters are applied - \"and\" or \"or\" (default: \"and\")\n        filter: List of collection filters (e.g., [\"label__endswith:0003\"])\n        **kwargs: Additional query parameters\n\n    Returns:\n        MetrcCollectionResponse containing data from the endpoint\n\n    Raises:\n        T3HTTPError: If request fails or client not authenticated\n    \"\"\"\n    # Use sync HTTP client to avoid event loop conflicts\n    from t3api_utils.http.utils import request_json\n\n    if not client.is_authenticated:\n        raise T3HTTPError(\"Client is not authenticated. Call authenticate_with_credentials() first.\")\n\n    # Prepare query parameters\n    params = {\n        \"licenseNumber\": license_number,\n        \"page\": page,\n        \"pageSize\": page_size,\n        \"strictPagination\": strict_pagination,\n        \"filterLogic\": filter_logic,\n        **kwargs,\n    }\n\n    # Add optional parameters only if they're provided\n    if sort is not None:\n        params[\"sort\"] = sort\n    if filter is not None:\n        params[\"filter\"] = filter\n\n    # Extract auth headers\n    headers_dict = {}\n    if client.access_token:\n        headers_dict[\"Authorization\"] = f\"Bearer {client.access_token}\"\n\n    try:\n        # Create a sync httpx client for this operation\n        import httpx\n\n        # Prepare client kwargs, handling optional parameters properly\n        client_kwargs: Dict[str, Any] = {\n            \"base_url\": client._config.host,\n            \"timeout\": client._config.timeout,\n            \"verify\": client._config.ssl_context,\n        }\n\n        if client._config.base_headers:\n            client_kwargs[\"headers\"] = client._config.base_headers\n\n        if client._config.proxies:\n            client_kwargs[\"proxies\"] = client._config.proxies\n\n        with httpx.Client(**client_kwargs) as sync_client:\n            response_data = request_json(\n                client=sync_client,\n                method=\"GET\",\n                url=path,\n                params=params,\n                headers=headers_dict,\n                policy=client._retry_policy,\n                expected_status=200,\n            )\n\n            return cast(MetrcCollectionResponse, response_data)\n\n    except T3HTTPError as e:\n        raise T3HTTPError(f\"Failed to get collection from {path}: {e}\", response=e.response) from e\n</code></pre>"},{"location":"reference/api-operations/#t3api_utils.api.operations.get_collection_async","title":"get_collection_async  <code>async</code>","text":"<pre><code>get_collection_async(client: T3APIClient, path: str, *, license_number: str, page: int = 1, page_size: int = 100, strict_pagination: bool = False, sort: Optional[str] = None, filter_logic: Literal['and', 'or'] = 'and', filter: Optional[List[str]] = None, **kwargs: Any) -&gt; MetrcCollectionResponse\n</code></pre> <p>Get a collection from any T3 API endpoint using an async client.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>T3APIClient</code> <p>Authenticated T3APIClient instance</p> required <code>path</code> <code>str</code> <p>API endpoint path (e.g., \"/v2/licenses\", \"/v2/packages/active\")</p> required <code>license_number</code> <code>str</code> <p>The unique identifier for the license (required)</p> required <code>page</code> <code>int</code> <p>Page number (1-based, default: 1)</p> <code>1</code> <code>page_size</code> <code>int</code> <p>Number of items per page (default: 100)</p> <code>100</code> <code>strict_pagination</code> <code>bool</code> <p>If enabled, out of bounds pages throw 400 (default: False)</p> <code>False</code> <code>sort</code> <code>Optional[str]</code> <p>Collection sort order (e.g., \"label:asc\")</p> <code>None</code> <code>filter_logic</code> <code>Literal['and', 'or']</code> <p>How filters are applied - \"and\" or \"or\" (default: \"and\")</p> <code>'and'</code> <code>filter</code> <code>Optional[List[str]]</code> <p>List of collection filters (e.g., [\"label__endswith:0003\"])</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional query parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>MetrcCollectionResponse</code> <p>MetrcCollectionResponse containing data from the endpoint</p> <p>Raises:</p> Type Description <code>T3HTTPError</code> <p>If request fails or client not authenticated</p> Source code in <code>t3api_utils/api/operations.py</code> <pre><code>async def get_collection_async(\n    client: T3APIClient,\n    path: str,\n    *,\n    license_number: str,\n    page: int = 1,\n    page_size: int = 100,\n    strict_pagination: bool = False,\n    sort: Optional[str] = None,\n    filter_logic: Literal[\"and\", \"or\"] = \"and\",\n    filter: Optional[List[str]] = None,\n    **kwargs: Any,\n) -&gt; MetrcCollectionResponse:\n    \"\"\"Get a collection from any T3 API endpoint using an async client.\n\n    Args:\n        client: Authenticated T3APIClient instance\n        path: API endpoint path (e.g., \"/v2/licenses\", \"/v2/packages/active\")\n        license_number: The unique identifier for the license (required)\n        page: Page number (1-based, default: 1)\n        page_size: Number of items per page (default: 100)\n        strict_pagination: If enabled, out of bounds pages throw 400 (default: False)\n        sort: Collection sort order (e.g., \"label:asc\")\n        filter_logic: How filters are applied - \"and\" or \"or\" (default: \"and\")\n        filter: List of collection filters (e.g., [\"label__endswith:0003\"])\n        **kwargs: Additional query parameters\n\n    Returns:\n        MetrcCollectionResponse containing data from the endpoint\n\n    Raises:\n        T3HTTPError: If request fails or client not authenticated\n    \"\"\"\n    if not client.is_authenticated:\n        raise T3HTTPError(\"Client is not authenticated. Call authenticate_with_credentials() first.\")\n\n    # Prepare query parameters\n    params = {\n        \"licenseNumber\": license_number,\n        \"page\": page,\n        \"pageSize\": page_size,\n        \"strictPagination\": strict_pagination,\n        \"filterLogic\": filter_logic,\n        **kwargs,\n    }\n\n    # Add optional parameters only if they're provided\n    if sort is not None:\n        params[\"sort\"] = sort\n    if filter is not None:\n        params[\"filter\"] = filter\n\n    try:\n        response_data = await arequest_json(\n            aclient=client._client,\n            method=\"GET\",\n            url=path,\n            params=params,\n            policy=client._retry_policy,\n            expected_status=200,\n        )\n\n        return cast(MetrcCollectionResponse, response_data)\n\n    except T3HTTPError as e:\n        raise T3HTTPError(f\"Failed to get collection from {path}: {e}\", response=e.response) from e\n</code></pre>"},{"location":"reference/api-operations/#t3api_utils.api.operations.send_api_request_async","title":"send_api_request_async  <code>async</code>","text":"<pre><code>send_api_request_async(client: T3APIClient, path: str, *, method: str = 'GET', params: Optional[Dict[str, Any]] = None, json_body: Optional[Any] = None, headers: Optional[Dict[str, str]] = None, expected_status: Union[int, tuple[int, ...]] = 200) -&gt; Any\n</code></pre> <p>Send a request to any T3 API endpoint using an async client.</p> <p>This is the most flexible operation that doesn't assume any specific parameter structure or response format.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>T3APIClient</code> <p>Authenticated T3APIClient instance</p> required <code>path</code> <code>str</code> <p>API endpoint path (e.g., \"/v2/licenses\", \"/v2/packages/active\", \"/v2/facilities/123\")</p> required <code>method</code> <code>str</code> <p>HTTP method (default: \"GET\")</p> <code>'GET'</code> <code>params</code> <code>Optional[Dict[str, Any]]</code> <p>Query parameters (optional)</p> <code>None</code> <code>json_body</code> <code>Optional[Any]</code> <p>JSON request body for POST/PUT requests (optional)</p> <code>None</code> <code>headers</code> <code>Optional[Dict[str, str]]</code> <p>Additional headers (optional)</p> <code>None</code> <code>expected_status</code> <code>Union[int, tuple[int, ...]]</code> <p>Expected HTTP status code(s) (default: 200)</p> <code>200</code> <p>Returns:</p> Type Description <code>Any</code> <p>Raw response data (could be dict, list, or any JSON-serializable type)</p> <p>Raises:</p> Type Description <code>T3HTTPError</code> <p>If request fails or client not authenticated</p> Source code in <code>t3api_utils/api/operations.py</code> <pre><code>async def send_api_request_async(\n    client: T3APIClient,\n    path: str,\n    *,\n    method: str = \"GET\",\n    params: Optional[Dict[str, Any]] = None,\n    json_body: Optional[Any] = None,\n    headers: Optional[Dict[str, str]] = None,\n    expected_status: Union[int, tuple[int, ...]] = 200,\n) -&gt; Any:\n    \"\"\"Send a request to any T3 API endpoint using an async client.\n\n    This is the most flexible operation that doesn't assume any specific\n    parameter structure or response format.\n\n    Args:\n        client: Authenticated T3APIClient instance\n        path: API endpoint path (e.g., \"/v2/licenses\", \"/v2/packages/active\", \"/v2/facilities/123\")\n        method: HTTP method (default: \"GET\")\n        params: Query parameters (optional)\n        json_body: JSON request body for POST/PUT requests (optional)\n        headers: Additional headers (optional)\n        expected_status: Expected HTTP status code(s) (default: 200)\n\n    Returns:\n        Raw response data (could be dict, list, or any JSON-serializable type)\n\n    Raises:\n        T3HTTPError: If request fails or client not authenticated\n    \"\"\"\n    if not client.is_authenticated:\n        raise T3HTTPError(\"Client is not authenticated. Call authenticate_with_credentials() first.\")\n\n    try:\n        response_data = await arequest_json(\n            aclient=client._client,\n            method=method,\n            url=path,\n            params=params,\n            json_body=json_body,\n            headers=headers,\n            policy=client._retry_policy,\n            expected_status=expected_status,\n        )\n\n        return response_data\n\n    except T3HTTPError as e:\n        raise T3HTTPError(f\"Failed to get data from {path}: {e}\", response=e.response) from e\n</code></pre>"},{"location":"reference/api-parallel/","title":"Parallel Loading","text":""},{"location":"reference/api-parallel/#t3api_utils.api.parallel","title":"parallel","text":"<p>Enhanced parallel API utilities for T3 API client.</p> <p>This module provides enhanced parallel loading capabilities that work with our httpx-based T3APIClient, including async support, rate limiting, and batching features.</p>"},{"location":"reference/api-parallel/#t3api_utils.api.parallel.RateLimiter","title":"RateLimiter","text":"<pre><code>RateLimiter(requests_per_second: float = 10.0)\n</code></pre> <p>Simple rate limiter using a token-bucket-style algorithm.</p> <p>Enforces a minimum time interval between consecutive requests to avoid overwhelming the API. The limiter tracks the timestamp of the last request and sleeps for the remaining interval before allowing the next one. Both synchronous (<code>time.sleep</code>) and asynchronous (<code>asyncio.sleep</code>) acquisition methods are provided.</p> <p>Attributes:</p> Name Type Description <code>requests_per_second</code> <p>Configured maximum throughput.</p> <code>min_interval</code> <p>Minimum seconds between consecutive requests, derived as <code>1.0 / requests_per_second</code>.</p> <code>last_request_time</code> <p>Epoch timestamp of the most recent request.</p> <p>Initialize rate limiter.</p> <p>Parameters:</p> Name Type Description Default <code>requests_per_second</code> <code>float</code> <p>Maximum requests per second allowed. A value of <code>0</code> or less disables rate limiting.</p> <code>10.0</code> Source code in <code>t3api_utils/api/parallel.py</code> <pre><code>def __init__(self, requests_per_second: float = 10.0) -&gt; None:\n    \"\"\"Initialize rate limiter.\n\n    Args:\n        requests_per_second: Maximum requests per second allowed.\n            A value of ``0`` or less disables rate limiting.\n    \"\"\"\n    self.requests_per_second = requests_per_second\n    self.min_interval = 1.0 / requests_per_second if requests_per_second &gt; 0 else 0\n    self.last_request_time = 0.0\n</code></pre>"},{"location":"reference/api-parallel/#t3api_utils.api.parallel.RateLimiter.acquire","title":"acquire","text":"<pre><code>acquire() -&gt; None\n</code></pre> <p>Block synchronously until it's safe to make another request.</p> <p>Uses <code>time.sleep</code> to pause the calling thread when the elapsed time since the last request is less than <code>min_interval</code>.</p> Source code in <code>t3api_utils/api/parallel.py</code> <pre><code>def acquire(self) -&gt; None:\n    \"\"\"Block synchronously until it's safe to make another request.\n\n    Uses ``time.sleep`` to pause the calling thread when the elapsed\n    time since the last request is less than ``min_interval``.\n    \"\"\"\n    if self.min_interval &lt;= 0:\n        return\n\n    current_time = time.time()\n    time_since_last = current_time - self.last_request_time\n\n    if time_since_last &lt; self.min_interval:\n        sleep_time = self.min_interval - time_since_last\n        time.sleep(sleep_time)\n\n    self.last_request_time = time.time()\n</code></pre>"},{"location":"reference/api-parallel/#t3api_utils.api.parallel.RateLimiter.acquire_async","title":"acquire_async  <code>async</code>","text":"<pre><code>acquire_async() -&gt; None\n</code></pre> <p>Asynchronously wait until it's safe to make another request.</p> <p>Uses <code>asyncio.sleep</code> instead of <code>time.sleep</code> so that the event loop remains unblocked while waiting for the rate-limit interval to elapse.</p> Source code in <code>t3api_utils/api/parallel.py</code> <pre><code>async def acquire_async(self) -&gt; None:\n    \"\"\"Asynchronously wait until it's safe to make another request.\n\n    Uses ``asyncio.sleep`` instead of ``time.sleep`` so that the\n    event loop remains unblocked while waiting for the rate-limit\n    interval to elapse.\n    \"\"\"\n    if self.min_interval &lt;= 0:\n        return\n\n    current_time = time.time()\n    time_since_last = current_time - self.last_request_time\n\n    if time_since_last &lt; self.min_interval:\n        sleep_time = self.min_interval - time_since_last\n        await asyncio.sleep(sleep_time)\n\n    self.last_request_time = time.time()\n</code></pre>"},{"location":"reference/api-parallel/#t3api_utils.api.parallel.parallel_load_paginated_sync","title":"parallel_load_paginated_sync","text":"<pre><code>parallel_load_paginated_sync(client: T3APIClient, path: str, max_workers: Optional[int] = None, rate_limit: Optional[float] = 10.0, **method_kwargs: Any) -&gt; List[PaginatedT]\n</code></pre> <p>Load all pages of a paginated API endpoint in parallel (sync wrapper).</p> <p>This is a wrapper around the async implementation using asyncio.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>T3APIClient</code> <p>Authenticated T3APIClient instance</p> required <code>path</code> <code>str</code> <p>API endpoint path (e.g., \"/v2/licenses\", \"/v2/packages/active\")</p> required <code>max_workers</code> <code>Optional[int]</code> <p>Maximum number of threads to use (maps to max_concurrent for async)</p> <code>None</code> <code>rate_limit</code> <code>Optional[float]</code> <p>Requests per second limit (None to disable)</p> <code>10.0</code> <code>**method_kwargs</code> <code>Any</code> <p>Arguments to pass to the API method</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[PaginatedT]</code> <p>List of paginated response objects, one per page</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If response is invalid</p> <code>AttributeError</code> <p>If client is not authenticated</p> Source code in <code>t3api_utils/api/parallel.py</code> <pre><code>def parallel_load_paginated_sync(\n    client: T3APIClient,\n    path: str,\n    max_workers: Optional[int] = None,\n    rate_limit: Optional[float] = 10.0,\n    **method_kwargs: Any,\n) -&gt; List[PaginatedT]:\n    \"\"\"\n    Load all pages of a paginated API endpoint in parallel (sync wrapper).\n\n    This is a wrapper around the async implementation using asyncio.\n\n    Args:\n        client: Authenticated T3APIClient instance\n        path: API endpoint path (e.g., \"/v2/licenses\", \"/v2/packages/active\")\n        max_workers: Maximum number of threads to use (maps to max_concurrent for async)\n        rate_limit: Requests per second limit (None to disable)\n        **method_kwargs: Arguments to pass to the API method\n\n    Returns:\n        List of paginated response objects, one per page\n\n    Raises:\n        ValueError: If response is invalid\n        AttributeError: If client is not authenticated\n    \"\"\"\n    # Create a temporary async client that uses the same config and auth\n    # but runs in its own event loop to avoid conflicts\n    import concurrent.futures\n\n    def run_in_thread() -&gt; List[PaginatedT]:\n        # Create a new event loop for this thread\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n        try:\n            # Import here to avoid circular imports\n            from t3api_utils.api.client import T3APIClient as TempClient\n\n            # Create a new client with the same config and auth\n            temp_client = TempClient(\n                config=client._config,\n                retry_policy=client._retry_policy,\n                logging_hooks=client._logging_hooks,\n                headers=client._extra_headers,\n            )\n            if client.access_token:\n                temp_client.set_access_token(client.access_token)\n\n            return loop.run_until_complete(parallel_load_paginated_async(\n                client=temp_client,\n                path=path,\n                max_concurrent=max_workers,\n                rate_limit=rate_limit,\n                **method_kwargs,\n            ))\n        finally:\n            loop.close()\n\n    # Run in a separate thread with its own event loop\n    with concurrent.futures.ThreadPoolExecutor(max_workers=1) as executor:\n        future = executor.submit(run_in_thread)\n        return future.result()\n</code></pre>"},{"location":"reference/api-parallel/#t3api_utils.api.parallel.parallel_load_paginated_async","title":"parallel_load_paginated_async  <code>async</code>","text":"<pre><code>parallel_load_paginated_async(client: T3APIClient, path: str, max_concurrent: Optional[int] = 10, rate_limit: Optional[float] = 10.0, batch_size: Optional[int] = None, **method_kwargs: Any) -&gt; List[PaginatedT]\n</code></pre> <p>Load all pages of a paginated API endpoint in parallel using async client.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>T3APIClient</code> <p>Authenticated T3APIClient instance</p> required <code>path</code> <code>str</code> <p>API endpoint path (e.g., \"/v2/licenses\", \"/v2/packages/active\")</p> required <code>max_concurrent</code> <code>Optional[int]</code> <p>Maximum number of concurrent requests</p> <code>10</code> <code>rate_limit</code> <code>Optional[float]</code> <p>Requests per second limit (None to disable)</p> <code>10.0</code> <code>batch_size</code> <code>Optional[int]</code> <p>Process requests in batches of this size (None for no batching)</p> <code>None</code> <code>**method_kwargs</code> <code>Any</code> <p>Arguments to pass to the API method</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[PaginatedT]</code> <p>List of paginated response objects, one per page</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If response is invalid</p> <code>AttributeError</code> <p>If client is not authenticated</p> Source code in <code>t3api_utils/api/parallel.py</code> <pre><code>async def parallel_load_paginated_async(\n    client: T3APIClient,\n    path: str,\n    max_concurrent: Optional[int] = 10,\n    rate_limit: Optional[float] = 10.0,\n    batch_size: Optional[int] = None,\n    **method_kwargs: Any,\n) -&gt; List[PaginatedT]:\n    \"\"\"\n    Load all pages of a paginated API endpoint in parallel using async client.\n\n    Args:\n        client: Authenticated T3APIClient instance\n        path: API endpoint path (e.g., \"/v2/licenses\", \"/v2/packages/active\")\n        max_concurrent: Maximum number of concurrent requests\n        rate_limit: Requests per second limit (None to disable)\n        batch_size: Process requests in batches of this size (None for no batching)\n        **method_kwargs: Arguments to pass to the API method\n\n    Returns:\n        List of paginated response objects, one per page\n\n    Raises:\n        ValueError: If response is invalid\n        AttributeError: If client is not authenticated\n    \"\"\"\n    if not client.is_authenticated:\n        raise AttributeError(\"Client must be authenticated before loading data\")\n\n    logger.info(f\"Starting parallel async load for {path}\")\n\n    # Set up rate limiter\n    rate_limiter = RateLimiter(rate_limit) if rate_limit else None\n\n    # Fetch first page to determine pagination\n    if rate_limiter:\n        await rate_limiter.acquire_async()\n\n    first_response = cast(PaginatedT, await get_collection_async(client, path, page=1, **method_kwargs))\n\n    if 'total' not in first_response or 'pageSize' not in first_response:\n        raise ValueError(\"Response must have 'total' and 'pageSize' fields\")\n\n    total_records = first_response[\"total\"]\n    page_size = first_response[\"pageSize\"]\n    num_pages = (total_records + page_size - 1) // page_size\n\n    logger.info(f\"Total records: {total_records}, page size: {page_size}, pages: {num_pages}\")\n\n    if num_pages &lt;= 1:\n        return [first_response]\n\n    async def fetch_page(page_number: int) -&gt; tuple[int, PaginatedT]:\n        \"\"\"Fetch a single page from the paginated endpoint.\n\n        Respects the outer rate limiter (if configured) before issuing\n        the request.\n\n        Args:\n            page_number: 1-based page number to fetch.\n\n        Returns:\n            A tuple of ``(zero_based_index, response)`` where the index\n            is ``page_number - 1``, suitable for direct insertion into\n            the pre-allocated responses list.\n        \"\"\"\n        if rate_limiter:\n            await rate_limiter.acquire_async()\n\n        logger.debug(f\"Fetching page {page_number}\")\n        response = cast(PaginatedT, await get_collection_async(client, path, page=page_number, **method_kwargs))\n        return page_number - 1, response  # Convert to 0-based index\n\n    # Prepare responses list\n    responses: List[PaginatedT] = [None] * num_pages  # type: ignore\n    responses[0] = first_response\n\n    remaining_pages = list(range(2, num_pages + 1))\n\n    if batch_size and batch_size &gt; 0:\n        # Process in batches\n        logger.info(f\"Processing {len(remaining_pages)} pages in batches of {batch_size}\")\n\n        for i in range(0, len(remaining_pages), batch_size):\n            batch_pages = remaining_pages[i:i + batch_size]\n            logger.info(f\"Processing batch {i // batch_size + 1}: pages {batch_pages[0]}-{batch_pages[-1]}\")\n\n            # Create semaphore for this batch\n            semaphore = asyncio.Semaphore(max_concurrent or len(batch_pages))\n\n            async def fetch_with_semaphore(page_num: int) -&gt; tuple[int, PaginatedT]:\n                async with semaphore:\n                    return await fetch_page(page_num)\n\n            # Execute batch\n            batch_tasks = [fetch_with_semaphore(page_num) for page_num in batch_pages]\n            batch_results = await asyncio.gather(*batch_tasks)\n\n            # Store results\n            for page_index, response in batch_results:\n                responses[page_index] = response\n\n            logger.info(f\"Completed batch {i // batch_size + 1}\")\n    else:\n        # Process all at once with concurrency limit\n        semaphore = asyncio.Semaphore(max_concurrent or len(remaining_pages))\n\n        async def fetch_with_semaphore(page_num: int) -&gt; tuple[int, PaginatedT]:\n            async with semaphore:\n                return await fetch_page(page_num)\n\n        # Create all tasks\n        tasks = [fetch_with_semaphore(page_num) for page_num in remaining_pages]\n\n        # Execute with progress tracking\n        for i, task in enumerate(asyncio.as_completed(tasks)):\n            page_index, response = await task\n            responses[page_index] = response\n            logger.info(f\"Loaded page {page_index + 1} ({i + 1}/{len(remaining_pages)})\")\n\n    logger.info(\"Finished parallel async load\")\n    return [r for r in responses if r is not None]\n</code></pre>"},{"location":"reference/api-parallel/#t3api_utils.api.parallel.load_all_data_sync","title":"load_all_data_sync","text":"<pre><code>load_all_data_sync(client: T3APIClient, path: str, max_workers: Optional[int] = None, rate_limit: Optional[float] = 10.0, **method_kwargs: Any) -&gt; List[T]\n</code></pre> <p>Load all data from a paginated endpoint and flatten into a single list (sync).</p> <p>This is a wrapper around the async implementation using asyncio.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>T3APIClient</code> <p>Authenticated T3APIClient instance</p> required <code>path</code> <code>str</code> <p>API endpoint path (e.g., \"/v2/licenses\", \"/v2/packages/active\")</p> required <code>max_workers</code> <code>Optional[int]</code> <p>Maximum number of threads to use (maps to max_concurrent for async)</p> <code>None</code> <code>rate_limit</code> <code>Optional[float]</code> <p>Requests per second limit (None to disable)</p> <code>10.0</code> <code>**method_kwargs</code> <code>Any</code> <p>Arguments to pass to the API method</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[T]</code> <p>Flattened list of all data items across all pages</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the first response is missing required pagination fields (<code>total</code> or <code>pageSize</code>).</p> <code>AttributeError</code> <p>If the client is not authenticated.</p> Source code in <code>t3api_utils/api/parallel.py</code> <pre><code>def load_all_data_sync(\n    client: T3APIClient,\n    path: str,\n    max_workers: Optional[int] = None,\n    rate_limit: Optional[float] = 10.0,\n    **method_kwargs: Any,\n) -&gt; List[T]:\n    \"\"\"\n    Load all data from a paginated endpoint and flatten into a single list (sync).\n\n    This is a wrapper around the async implementation using asyncio.\n\n    Args:\n        client: Authenticated T3APIClient instance\n        path: API endpoint path (e.g., \"/v2/licenses\", \"/v2/packages/active\")\n        max_workers: Maximum number of threads to use (maps to max_concurrent for async)\n        rate_limit: Requests per second limit (None to disable)\n        **method_kwargs: Arguments to pass to the API method\n\n    Returns:\n        Flattened list of all data items across all pages\n\n    Raises:\n        ValueError: If the first response is missing required pagination\n            fields (``total`` or ``pageSize``).\n        AttributeError: If the client is not authenticated.\n    \"\"\"\n    # Create a temporary async client that uses the same config and auth\n    # but runs in its own event loop to avoid conflicts\n    import concurrent.futures\n\n    def run_in_thread() -&gt; List[T]:\n        # Create a new event loop for this thread\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n        try:\n            # Import here to avoid circular imports\n            from t3api_utils.api.client import T3APIClient as TempClient\n\n            # Create a new client with the same config and auth\n            temp_client = TempClient(\n                config=client._config,\n                retry_policy=client._retry_policy,\n                logging_hooks=client._logging_hooks,\n                headers=client._extra_headers,\n            )\n            if client.access_token:\n                temp_client.set_access_token(client.access_token)\n\n            return loop.run_until_complete(load_all_data_async(\n                client=temp_client,\n                path=path,\n                max_concurrent=max_workers,\n                rate_limit=rate_limit,\n                **method_kwargs,\n            ))\n        finally:\n            loop.close()\n\n    # Run in a separate thread with its own event loop\n    with concurrent.futures.ThreadPoolExecutor(max_workers=1) as executor:\n        future = executor.submit(run_in_thread)\n        return future.result()\n</code></pre>"},{"location":"reference/api-parallel/#t3api_utils.api.parallel.load_all_data_async","title":"load_all_data_async  <code>async</code>","text":"<pre><code>load_all_data_async(client: T3APIClient, path: str, max_concurrent: Optional[int] = 10, rate_limit: Optional[float] = 10.0, batch_size: Optional[int] = None, **method_kwargs: Any) -&gt; List[T]\n</code></pre> <p>Load all data from a paginated endpoint and flatten into a single list (async).</p> <p>This is a convenience function that combines parallel_load_paginated_async with data extraction.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>T3APIClient</code> <p>Authenticated T3APIClient instance</p> required <code>path</code> <code>str</code> <p>API endpoint path (e.g., \"/v2/licenses\", \"/v2/packages/active\")</p> required <code>max_concurrent</code> <code>Optional[int]</code> <p>Maximum number of concurrent requests</p> <code>10</code> <code>rate_limit</code> <code>Optional[float]</code> <p>Requests per second limit (None to disable)</p> <code>10.0</code> <code>batch_size</code> <code>Optional[int]</code> <p>Process requests in batches of this size (None for no batching)</p> <code>None</code> <code>**method_kwargs</code> <code>Any</code> <p>Arguments to pass to the API method</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[T]</code> <p>Flattened list of all data items across all pages</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the first response is missing required pagination fields (<code>total</code> or <code>pageSize</code>).</p> <code>AttributeError</code> <p>If the client is not authenticated.</p> Source code in <code>t3api_utils/api/parallel.py</code> <pre><code>async def load_all_data_async(\n    client: T3APIClient,\n    path: str,\n    max_concurrent: Optional[int] = 10,\n    rate_limit: Optional[float] = 10.0,\n    batch_size: Optional[int] = None,\n    **method_kwargs: Any,\n) -&gt; List[T]:\n    \"\"\"\n    Load all data from a paginated endpoint and flatten into a single list (async).\n\n    This is a convenience function that combines parallel_load_paginated_async\n    with data extraction.\n\n    Args:\n        client: Authenticated T3APIClient instance\n        path: API endpoint path (e.g., \"/v2/licenses\", \"/v2/packages/active\")\n        max_concurrent: Maximum number of concurrent requests\n        rate_limit: Requests per second limit (None to disable)\n        batch_size: Process requests in batches of this size (None for no batching)\n        **method_kwargs: Arguments to pass to the API method\n\n    Returns:\n        Flattened list of all data items across all pages\n\n    Raises:\n        ValueError: If the first response is missing required pagination\n            fields (``total`` or ``pageSize``).\n        AttributeError: If the client is not authenticated.\n    \"\"\"\n    responses: List[MetrcCollectionResponse] = await parallel_load_paginated_async(\n        client=client,\n        path=path,\n        max_concurrent=max_concurrent,\n        rate_limit=rate_limit,\n        batch_size=batch_size,\n        **method_kwargs,\n    )\n\n    # Extract all data items\n    all_data: List[T] = []\n    for response in responses:\n        all_data.extend(cast(List[T], response[\"data\"]))\n\n    return all_data\n</code></pre>"},{"location":"reference/api-parallel/#t3api_utils.api.parallel.parallel_load_collection_enhanced","title":"parallel_load_collection_enhanced","text":"<pre><code>parallel_load_collection_enhanced(method: Callable[..., PaginatedT], max_workers: Optional[int] = None, rate_limit: Optional[float] = None, **method_kwargs: Any) -&gt; List[PaginatedT]\n</code></pre> <p>Enhanced version of the original parallel_load_collection with rate limiting.</p> <p>This function maintains backwards compatibility with the original interface while adding rate limiting capabilities.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Callable[..., PaginatedT]</code> <p>Callable that returns a paginated response. Must accept a <code>page</code> keyword argument.</p> required <code>max_workers</code> <code>Optional[int]</code> <p>Maximum number of threads to use</p> <code>None</code> <code>rate_limit</code> <code>Optional[float]</code> <p>Requests per second limit (None to disable)</p> <code>None</code> <code>**method_kwargs</code> <code>Any</code> <p>Arguments to pass to the method</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[PaginatedT]</code> <p>List of paginated response objects</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the first response is missing a <code>total</code> field or the page size cannot be determined from the response.</p> Source code in <code>t3api_utils/api/parallel.py</code> <pre><code>def parallel_load_collection_enhanced(\n    method: Callable[..., PaginatedT],\n    max_workers: Optional[int] = None,\n    rate_limit: Optional[float] = None,\n    **method_kwargs: Any,\n) -&gt; List[PaginatedT]:\n    \"\"\"\n    Enhanced version of the original parallel_load_collection with rate limiting.\n\n    This function maintains backwards compatibility with the original interface\n    while adding rate limiting capabilities.\n\n    Args:\n        method: Callable that returns a paginated response. Must accept a\n            ``page`` keyword argument.\n        max_workers: Maximum number of threads to use\n        rate_limit: Requests per second limit (None to disable)\n        **method_kwargs: Arguments to pass to the method\n\n    Returns:\n        List of paginated response objects\n\n    Raises:\n        ValueError: If the first response is missing a ``total`` field or\n            the page size cannot be determined from the response.\n    \"\"\"\n    logger.info(\"Starting enhanced parallel data load\")\n\n    # Set up rate limiter\n    rate_limiter = RateLimiter(rate_limit) if rate_limit else None\n\n    # Fetch first page\n    if rate_limiter:\n        rate_limiter.acquire()\n\n    first_response = method(page=1, **method_kwargs)\n\n    if \"total\" not in first_response or first_response[\"total\"] is None:\n        raise ValueError(\"Response missing required `total` field.\")\n\n    total = first_response[\"total\"]\n\n    page_size = first_response.get(\"pageSize\")\n    if page_size is None:\n        data = first_response.get(\"data\", [])\n        page_size = len(cast(List[Any], data)) if data is not None else 0\n    if page_size is None or page_size == 0:\n        raise ValueError(\"Unable to determine page size from first response.\")\n\n    # Type assertion since we know page_size is int at this point\n    assert isinstance(page_size, int)\n    num_pages = (total + page_size - 1) // page_size\n    logger.info(f\"Total records: {total}, page size: {page_size}, total pages: {num_pages}\")\n\n    if num_pages &lt;= 1:\n        return [first_response]\n\n    responses: List[PaginatedT] = [None] * num_pages  # type: ignore\n    responses[0] = first_response\n\n    def fetch_page(page_number: int) -&gt; tuple[int, PaginatedT]:\n        \"\"\"Fetch a single page using the provided callable.\n\n        Respects the outer rate limiter (if configured) before issuing\n        the request.\n\n        Args:\n            page_number: 0-based page index. The actual API call uses\n                ``page_number + 1`` as the 1-based page parameter.\n\n        Returns:\n            A tuple of ``(page_number, response)`` for insertion into\n            the pre-allocated responses list.\n        \"\"\"\n        if rate_limiter:\n            rate_limiter.acquire()\n\n        logger.debug(f\"Fetching page {page_number + 1}\")\n        response = method(page=page_number + 1, **method_kwargs)\n        return page_number, response\n\n    with ThreadPoolExecutor(max_workers=max_workers) as executor:\n        futures = [executor.submit(fetch_page, i) for i in range(1, num_pages)]\n        for count, future in enumerate(as_completed(futures), start=1):\n            page_number, response = future.result()\n            responses[page_number] = response\n            logger.info(f\"Loaded page {page_number + 1} ({count}/{num_pages - 1})\")\n\n    logger.info(\"Finished enhanced parallel loading\")\n    return [r for r in responses if r is not None]\n</code></pre>"},{"location":"reference/auth/","title":"Authentication","text":""},{"location":"reference/auth/#interfaces","title":"Interfaces","text":""},{"location":"reference/auth/#t3api_utils.auth.interfaces","title":"interfaces","text":"<p>Authentication credential interfaces for the T3 API.</p>"},{"location":"reference/auth/#t3api_utils.auth.interfaces.T3Credentials","title":"T3Credentials","text":"<p>               Bases: <code>TypedDict</code></p> <p>Credentials required to authenticate with the T3 API via Metrc.</p> <p>Used by :func:<code>t3api_utils.auth.utils.create_credentials_authenticated_client_or_error</code> and related helpers to build an authenticated API client.</p>"},{"location":"reference/auth/#t3api_utils.auth.interfaces.T3Credentials.hostname","title":"hostname  <code>instance-attribute</code>","text":"<pre><code>hostname: str\n</code></pre> <p>Metrc state hostname (e.g. <code>\"ca.metrc.com\"</code>, <code>\"co.metrc.com\"</code>).</p>"},{"location":"reference/auth/#t3api_utils.auth.interfaces.T3Credentials.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username: str\n</code></pre> <p>Metrc account username.</p>"},{"location":"reference/auth/#t3api_utils.auth.interfaces.T3Credentials.password","title":"password  <code>instance-attribute</code>","text":"<pre><code>password: str\n</code></pre> <p>Metrc account password.</p>"},{"location":"reference/auth/#t3api_utils.auth.interfaces.T3Credentials.otp","title":"otp  <code>instance-attribute</code>","text":"<pre><code>otp: Optional[str]\n</code></pre> <p>One-time password for two-factor authentication. Required for hostnames in the OTP whitelist (e.g. <code>mi.metrc.com</code>).</p>"},{"location":"reference/auth/#t3api_utils.auth.interfaces.T3Credentials.email","title":"email  <code>instance-attribute</code>","text":"<pre><code>email: Optional[str]\n</code></pre> <p>Email address associated with the Metrc account. Required for hostnames in the credential-email whitelist (e.g. <code>co.metrc.com</code>).</p>"},{"location":"reference/auth/#utilities","title":"Utilities","text":""},{"location":"reference/auth/#t3api_utils.auth.utils","title":"utils","text":"<p>Authentication utilities for T3 API using httpx-based client.</p> <p>This module provides authentication functions using our async httpx implementation with sync wrappers for compatibility.</p>"},{"location":"reference/auth/#t3api_utils.auth.utils.create_credentials_authenticated_client_or_error_async","title":"create_credentials_authenticated_client_or_error_async  <code>async</code>","text":"<pre><code>create_credentials_authenticated_client_or_error_async(*, hostname: str, username: str, password: str, host: Optional[str] = None, otp: Optional[str] = None, email: Optional[str] = None) -&gt; T3APIClient\n</code></pre> <p>Authenticates with the T3 API using credentials and returns an authenticated client (async).</p> <p>Parameters:</p> Name Type Description Default <code>hostname</code> <code>str</code> <p>Metrc hostname used for authentication (e.g., \"api-ca\").</p> required <code>username</code> <code>str</code> <p>Metrc account username.</p> required <code>password</code> <code>str</code> <p>Metrc account password.</p> required <code>host</code> <code>Optional[str]</code> <p>T3 API host URL. Defaults to production if not provided.</p> <code>None</code> <code>otp</code> <code>Optional[str]</code> <p>One-time password for multi-factor authentication.</p> <code>None</code> <code>email</code> <code>Optional[str]</code> <p>Email address associated with the Metrc account.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>T3APIClient</code> <code>T3APIClient</code> <p>An authenticated async client instance ready for use.</p> <p>Raises:</p> Type Description <code>AuthenticationError</code> <p>If authentication fails.</p> Source code in <code>t3api_utils/auth/utils.py</code> <pre><code>async def create_credentials_authenticated_client_or_error_async(\n    *,\n    hostname: str,\n    username: str,\n    password: str,\n    host: Optional[str] = None,\n    otp: Optional[str] = None,\n    email: Optional[str] = None,\n) -&gt; T3APIClient:\n    \"\"\"\n    Authenticates with the T3 API using credentials and returns an authenticated client (async).\n\n    Args:\n        hostname: Metrc hostname used for authentication (e.g., \"api-ca\").\n        username: Metrc account username.\n        password: Metrc account password.\n        host: T3 API host URL. Defaults to production if not provided.\n        otp: One-time password for multi-factor authentication.\n        email: Email address associated with the Metrc account.\n\n    Returns:\n        T3APIClient: An authenticated async client instance ready for use.\n\n    Raises:\n        AuthenticationError: If authentication fails.\n    \"\"\"\n    try:\n        # Create HTTP config with host from config or parameter\n        effective_host = host or config_manager.get_api_host()\n        config = HTTPConfig(host=effective_host)\n\n        # Create and authenticate the client\n        client = T3APIClient(config=config)\n\n        await client.authenticate_with_credentials(\n            hostname=hostname,\n            username=username,\n            password=password,\n            otp=otp,\n            email=email,\n        )\n\n        return client\n\n    except T3HTTPError as e:\n        raise AuthenticationError(f\"T3 API authentication failed: {e}\") from e\n    except Exception as e:\n        raise AuthenticationError(f\"Unexpected authentication error: {str(e)}\") from e\n</code></pre>"},{"location":"reference/auth/#t3api_utils.auth.utils.create_credentials_authenticated_client_or_error","title":"create_credentials_authenticated_client_or_error","text":"<pre><code>create_credentials_authenticated_client_or_error(*, hostname: str, username: str, password: str, host: Optional[str] = None, otp: Optional[str] = None, email: Optional[str] = None) -&gt; T3APIClient\n</code></pre> <p>Authenticates with the T3 API using credentials and returns an authenticated client (sync wrapper).</p> <p>This function provides a sync wrapper around the async implementation.</p> <p>Parameters:</p> Name Type Description Default <code>hostname</code> <code>str</code> <p>Metrc hostname used for authentication (e.g., \"api-ca\").</p> required <code>username</code> <code>str</code> <p>Metrc account username.</p> required <code>password</code> <code>str</code> <p>Metrc account password.</p> required <code>host</code> <code>Optional[str]</code> <p>T3 API host URL. Defaults to production if not provided.</p> <code>None</code> <code>otp</code> <code>Optional[str]</code> <p>One-time password for multi-factor authentication.</p> <code>None</code> <code>email</code> <code>Optional[str]</code> <p>Email address associated with the Metrc account.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>T3APIClient</code> <code>T3APIClient</code> <p>An authenticated client instance ready for use</p> <p>Raises:</p> Type Description <code>AuthenticationError</code> <p>If authentication fails</p> Source code in <code>t3api_utils/auth/utils.py</code> <pre><code>def create_credentials_authenticated_client_or_error(\n    *,\n    hostname: str,\n    username: str,\n    password: str,\n    host: Optional[str] = None,\n    otp: Optional[str] = None,\n    email: Optional[str] = None,\n) -&gt; T3APIClient:\n    \"\"\"\n    Authenticates with the T3 API using credentials and returns an authenticated client (sync wrapper).\n\n    This function provides a sync wrapper around the async implementation.\n\n    Args:\n        hostname: Metrc hostname used for authentication (e.g., \"api-ca\").\n        username: Metrc account username.\n        password: Metrc account password.\n        host: T3 API host URL. Defaults to production if not provided.\n        otp: One-time password for multi-factor authentication.\n        email: Email address associated with the Metrc account.\n\n    Returns:\n        T3APIClient: An authenticated client instance ready for use\n\n    Raises:\n        AuthenticationError: If authentication fails\n    \"\"\"\n    return asyncio.run(create_credentials_authenticated_client_or_error_async(\n        hostname=hostname,\n        username=username,\n        password=password,\n        host=host,\n        otp=otp,\n        email=email,\n    ))\n</code></pre>"},{"location":"reference/auth/#t3api_utils.auth.utils.authenticate_and_get_token_async","title":"authenticate_and_get_token_async  <code>async</code>","text":"<pre><code>authenticate_and_get_token_async(*, hostname: str, username: str, password: str, host: Optional[str] = None, otp: Optional[str] = None, email: Optional[str] = None) -&gt; str\n</code></pre> <p>Authenticate and return just the access token (async).</p> <p>This is a convenience function for when you only need the token and not the full client.</p> <p>Parameters:</p> Name Type Description Default <code>hostname</code> <code>str</code> <p>Metrc hostname used for authentication (e.g., \"api-ca\").</p> required <code>username</code> <code>str</code> <p>Metrc account username.</p> required <code>password</code> <code>str</code> <p>Metrc account password.</p> required <code>host</code> <code>Optional[str]</code> <p>T3 API host URL. Defaults to production if not provided.</p> <code>None</code> <code>otp</code> <code>Optional[str]</code> <p>One-time password for multi-factor authentication.</p> <code>None</code> <code>email</code> <code>Optional[str]</code> <p>Email address associated with the Metrc account.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The access token.</p> <p>Raises:</p> Type Description <code>AuthenticationError</code> <p>If authentication fails.</p> Source code in <code>t3api_utils/auth/utils.py</code> <pre><code>async def authenticate_and_get_token_async(\n    *,\n    hostname: str,\n    username: str,\n    password: str,\n    host: Optional[str] = None,\n    otp: Optional[str] = None,\n    email: Optional[str] = None,\n) -&gt; str:\n    \"\"\"\n    Authenticate and return just the access token (async).\n\n    This is a convenience function for when you only need the token\n    and not the full client.\n\n    Args:\n        hostname: Metrc hostname used for authentication (e.g., \"api-ca\").\n        username: Metrc account username.\n        password: Metrc account password.\n        host: T3 API host URL. Defaults to production if not provided.\n        otp: One-time password for multi-factor authentication.\n        email: Email address associated with the Metrc account.\n\n    Returns:\n        str: The access token.\n\n    Raises:\n        AuthenticationError: If authentication fails.\n    \"\"\"\n    client = await create_credentials_authenticated_client_or_error_async(\n        hostname=hostname,\n        username=username,\n        password=password,\n        host=host,\n        otp=otp,\n        email=email,\n    )\n\n    if client.access_token is None:\n        raise AuthenticationError(\"Authentication succeeded but no access token was returned\")\n\n    # Clean up the client\n    await client.close()\n\n    return client.access_token\n</code></pre>"},{"location":"reference/auth/#t3api_utils.auth.utils.authenticate_and_get_token","title":"authenticate_and_get_token","text":"<pre><code>authenticate_and_get_token(*, hostname: str, username: str, password: str, host: Optional[str] = None, otp: Optional[str] = None, email: Optional[str] = None) -&gt; str\n</code></pre> <p>Authenticate and return just the access token (sync wrapper).</p> <p>This is a convenience function for when you only need the token and not the full client.</p> <p>Parameters:</p> Name Type Description Default <code>hostname</code> <code>str</code> <p>Metrc hostname used for authentication (e.g., \"api-ca\").</p> required <code>username</code> <code>str</code> <p>Metrc account username.</p> required <code>password</code> <code>str</code> <p>Metrc account password.</p> required <code>host</code> <code>Optional[str]</code> <p>T3 API host URL. Defaults to production if not provided.</p> <code>None</code> <code>otp</code> <code>Optional[str]</code> <p>One-time password for multi-factor authentication.</p> <code>None</code> <code>email</code> <code>Optional[str]</code> <p>Email address associated with the Metrc account.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The access token</p> <p>Raises:</p> Type Description <code>AuthenticationError</code> <p>If authentication fails</p> Source code in <code>t3api_utils/auth/utils.py</code> <pre><code>def authenticate_and_get_token(\n    *,\n    hostname: str,\n    username: str,\n    password: str,\n    host: Optional[str] = None,\n    otp: Optional[str] = None,\n    email: Optional[str] = None,\n) -&gt; str:\n    \"\"\"\n    Authenticate and return just the access token (sync wrapper).\n\n    This is a convenience function for when you only need the token\n    and not the full client.\n\n    Args:\n        hostname: Metrc hostname used for authentication (e.g., \"api-ca\").\n        username: Metrc account username.\n        password: Metrc account password.\n        host: T3 API host URL. Defaults to production if not provided.\n        otp: One-time password for multi-factor authentication.\n        email: Email address associated with the Metrc account.\n\n    Returns:\n        str: The access token\n\n    Raises:\n        AuthenticationError: If authentication fails\n    \"\"\"\n    return asyncio.run(authenticate_and_get_token_async(\n        hostname=hostname,\n        username=username,\n        password=password,\n        host=host,\n        otp=otp,\n        email=email,\n    ))\n</code></pre>"},{"location":"reference/auth/#t3api_utils.auth.utils.authenticate_and_get_response_async","title":"authenticate_and_get_response_async  <code>async</code>","text":"<pre><code>authenticate_and_get_response_async(*, hostname: str, username: str, password: str, host: Optional[str] = None, otp: Optional[str] = None, email: Optional[str] = None) -&gt; AuthResponseData\n</code></pre> <p>Authenticate and return the full authentication response (async).</p> <p>This function provides access to all authentication response data including refresh tokens and expiration information.</p> <p>Parameters:</p> Name Type Description Default <code>hostname</code> <code>str</code> <p>Metrc hostname used for authentication (e.g., \"api-ca\").</p> required <code>username</code> <code>str</code> <p>Metrc account username.</p> required <code>password</code> <code>str</code> <p>Metrc account password.</p> required <code>host</code> <code>Optional[str]</code> <p>T3 API host URL. Defaults to production if not provided.</p> <code>None</code> <code>otp</code> <code>Optional[str]</code> <p>One-time password for multi-factor authentication.</p> <code>None</code> <code>email</code> <code>Optional[str]</code> <p>Email address associated with the Metrc account.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>AuthResponseData</code> <code>AuthResponseData</code> <p>The complete authentication response.</p> <p>Raises:</p> Type Description <code>AuthenticationError</code> <p>If authentication fails.</p> Source code in <code>t3api_utils/auth/utils.py</code> <pre><code>async def authenticate_and_get_response_async(\n    *,\n    hostname: str,\n    username: str,\n    password: str,\n    host: Optional[str] = None,\n    otp: Optional[str] = None,\n    email: Optional[str] = None,\n) -&gt; AuthResponseData:\n    \"\"\"\n    Authenticate and return the full authentication response (async).\n\n    This function provides access to all authentication response data\n    including refresh tokens and expiration information.\n\n    Args:\n        hostname: Metrc hostname used for authentication (e.g., \"api-ca\").\n        username: Metrc account username.\n        password: Metrc account password.\n        host: T3 API host URL. Defaults to production if not provided.\n        otp: One-time password for multi-factor authentication.\n        email: Email address associated with the Metrc account.\n\n    Returns:\n        AuthResponseData: The complete authentication response.\n\n    Raises:\n        AuthenticationError: If authentication fails.\n    \"\"\"\n    try:\n        # Create HTTP config with host from config or parameter\n        effective_host = host or config_manager.get_api_host()\n        config = HTTPConfig(host=effective_host)\n\n        # Create client and authenticate\n        async with T3APIClient(config=config) as client:\n            auth_response = await client.authenticate_with_credentials(\n                hostname=hostname,\n                username=username,\n                password=password,\n                otp=otp,\n                email=email,\n            )\n\n            return auth_response\n\n    except T3HTTPError as e:\n        raise AuthenticationError(f\"T3 API authentication failed: {e}\") from e\n    except Exception as e:\n        raise AuthenticationError(f\"Unexpected authentication error: {str(e)}\") from e\n</code></pre>"},{"location":"reference/auth/#t3api_utils.auth.utils.authenticate_and_get_response","title":"authenticate_and_get_response","text":"<pre><code>authenticate_and_get_response(*, hostname: str, username: str, password: str, host: Optional[str] = None, otp: Optional[str] = None, email: Optional[str] = None) -&gt; AuthResponseData\n</code></pre> <p>Authenticate and return the full authentication response (sync wrapper).</p> <p>This function provides access to all authentication response data including refresh tokens and expiration information.</p> <p>Parameters:</p> Name Type Description Default <code>hostname</code> <code>str</code> <p>Metrc hostname used for authentication (e.g., \"api-ca\").</p> required <code>username</code> <code>str</code> <p>Metrc account username.</p> required <code>password</code> <code>str</code> <p>Metrc account password.</p> required <code>host</code> <code>Optional[str]</code> <p>T3 API host URL. Defaults to production if not provided.</p> <code>None</code> <code>otp</code> <code>Optional[str]</code> <p>One-time password for multi-factor authentication.</p> <code>None</code> <code>email</code> <code>Optional[str]</code> <p>Email address associated with the Metrc account.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>AuthResponseData</code> <code>AuthResponseData</code> <p>The complete authentication response</p> <p>Raises:</p> Type Description <code>AuthenticationError</code> <p>If authentication fails</p> Source code in <code>t3api_utils/auth/utils.py</code> <pre><code>def authenticate_and_get_response(\n    *,\n    hostname: str,\n    username: str,\n    password: str,\n    host: Optional[str] = None,\n    otp: Optional[str] = None,\n    email: Optional[str] = None,\n) -&gt; AuthResponseData:\n    \"\"\"\n    Authenticate and return the full authentication response (sync wrapper).\n\n    This function provides access to all authentication response data\n    including refresh tokens and expiration information.\n\n    Args:\n        hostname: Metrc hostname used for authentication (e.g., \"api-ca\").\n        username: Metrc account username.\n        password: Metrc account password.\n        host: T3 API host URL. Defaults to production if not provided.\n        otp: One-time password for multi-factor authentication.\n        email: Email address associated with the Metrc account.\n\n    Returns:\n        AuthResponseData: The complete authentication response\n\n    Raises:\n        AuthenticationError: If authentication fails\n    \"\"\"\n    return asyncio.run(authenticate_and_get_response_async(\n        hostname=hostname,\n        username=username,\n        password=password,\n        host=host,\n        otp=otp,\n        email=email,\n    ))\n</code></pre>"},{"location":"reference/auth/#t3api_utils.auth.utils.create_jwt_authenticated_client","title":"create_jwt_authenticated_client","text":"<pre><code>create_jwt_authenticated_client(*, jwt_token: str, host: Optional[str] = None, config: Optional[HTTPConfig] = None, retry_policy: Optional[RetryPolicy] = None, logging_hooks: Optional[LoggingHooks] = None, headers: Optional[Dict[str, str]] = None) -&gt; T3APIClient\n</code></pre> <p>Creates an authenticated T3 API client using a pre-existing JWT token.</p> <p>This function allows users to directly provide their JWT token instead of going through the username/password authentication flow.</p> <p>Parameters:</p> Name Type Description Default <code>jwt_token</code> <code>str</code> <p>Valid JWT access token issued by the T3 API.</p> required <code>host</code> <code>Optional[str]</code> <p>T3 API host URL. Defaults to production if no config provided.</p> <code>None</code> <code>config</code> <code>Optional[HTTPConfig]</code> <p>HTTP configuration for timeout, SSL, and proxy settings.</p> <code>None</code> <code>retry_policy</code> <code>Optional[RetryPolicy]</code> <p>Retry policy controlling backoff and max attempts for failed requests.</p> <code>None</code> <code>logging_hooks</code> <code>Optional[LoggingHooks]</code> <p>Hooks for logging outgoing requests and incoming responses.</p> <code>None</code> <code>headers</code> <code>Optional[Dict[str, str]]</code> <p>Additional HTTP headers to include with every request.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>T3APIClient</code> <code>T3APIClient</code> <p>An authenticated async client instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If jwt_token is empty or None</p> Example <p>token = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\" client = create_jwt_authenticated_client(jwt_token=token)</p> Source code in <code>t3api_utils/auth/utils.py</code> <pre><code>def create_jwt_authenticated_client(\n    *,\n    jwt_token: str,\n    host: Optional[str] = None,\n    config: Optional[HTTPConfig] = None,\n    retry_policy: Optional[RetryPolicy] = None,\n    logging_hooks: Optional[LoggingHooks] = None,\n    headers: Optional[Dict[str, str]] = None,\n) -&gt; T3APIClient:\n    \"\"\"\n    Creates an authenticated T3 API client using a pre-existing JWT token.\n\n    This function allows users to directly provide their JWT token instead of\n    going through the username/password authentication flow.\n\n    Args:\n        jwt_token: Valid JWT access token issued by the T3 API.\n        host: T3 API host URL. Defaults to production if no config provided.\n        config: HTTP configuration for timeout, SSL, and proxy settings.\n        retry_policy: Retry policy controlling backoff and max attempts for failed requests.\n        logging_hooks: Hooks for logging outgoing requests and incoming responses.\n        headers: Additional HTTP headers to include with every request.\n\n    Returns:\n        T3APIClient: An authenticated async client instance\n\n    Raises:\n        ValueError: If jwt_token is empty or None\n\n    Example:\n        &gt;&gt;&gt; token = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\n        &gt;&gt;&gt; client = create_jwt_authenticated_client(jwt_token=token)\n        &gt;&gt;&gt; # Client is ready to use for API calls (note: it's async)\n    \"\"\"\n    if not jwt_token or not jwt_token.strip():\n        raise ValueError(\"JWT token cannot be empty or None\")\n\n    # Handle host and config parameters\n    if config is None:\n        # No config provided, create one with specified host or default\n        effective_host = host or config_manager.get_api_host()\n        config = HTTPConfig(host=effective_host)\n    elif host is not None and config.host != host:\n        # Config provided but different host explicitly specified\n        config = HTTPConfig(\n            host=host,\n            timeout=config.timeout,\n            verify_ssl=config.verify_ssl,\n            base_headers=config.base_headers,\n            proxies=config.proxies,\n        )\n    # Otherwise, use the provided config as-is\n\n    # Create the client\n    client = T3APIClient(\n        config=config,\n        retry_policy=retry_policy,\n        logging_hooks=logging_hooks,\n        headers=headers,\n    )\n\n    # Set the JWT token\n    client.set_access_token(jwt_token.strip())\n\n    return client\n</code></pre>"},{"location":"reference/auth/#t3api_utils.auth.utils.create_jwt_authenticated_client--client-is-ready-to-use-for-api-calls-note-its-async","title":"Client is ready to use for API calls (note: it's async)","text":""},{"location":"reference/auth/#t3api_utils.auth.utils.create_api_key_authenticated_client","title":"create_api_key_authenticated_client","text":"<pre><code>create_api_key_authenticated_client(*, api_key: str, state_code: str, host: Optional[str] = None, config: Optional[HTTPConfig] = None, retry_policy: Optional[RetryPolicy] = None, logging_hooks: Optional[LoggingHooks] = None, headers: Optional[Dict[str, str]] = None) -&gt; T3APIClient\n</code></pre> <p>Creates an authenticated T3 API client using an API key.</p> <p>This function provides API key authentication by calling the /v2/auth/apikey endpoint with the provided API key and state code.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>T3 API key used for authentication via the /v2/auth/apikey endpoint.</p> required <code>state_code</code> <code>str</code> <p>Two-letter US state code for the target Metrc instance (e.g., \"CA\", \"MO\").</p> required <code>host</code> <code>Optional[str]</code> <p>T3 API host URL. Defaults to production if no config provided.</p> <code>None</code> <code>config</code> <code>Optional[HTTPConfig]</code> <p>HTTP configuration for timeout, SSL, and proxy settings.</p> <code>None</code> <code>retry_policy</code> <code>Optional[RetryPolicy]</code> <p>Retry policy controlling backoff and max attempts for failed requests.</p> <code>None</code> <code>logging_hooks</code> <code>Optional[LoggingHooks]</code> <p>Hooks for logging outgoing requests and incoming responses.</p> <code>None</code> <code>headers</code> <code>Optional[Dict[str, str]]</code> <p>Additional HTTP headers to include with every request.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>T3APIClient</code> <code>T3APIClient</code> <p>An authenticated async client instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If api_key or state_code is empty or None</p> <code>AuthenticationError</code> <p>If API key authentication fails</p> Example <p>client = create_api_key_authenticated_client( ...     api_key=\"your-api-key\", ...     state_code=\"CA\" ... )</p> Source code in <code>t3api_utils/auth/utils.py</code> <pre><code>def create_api_key_authenticated_client(\n    *,\n    api_key: str,\n    state_code: str,\n    host: Optional[str] = None,\n    config: Optional[HTTPConfig] = None,\n    retry_policy: Optional[RetryPolicy] = None,\n    logging_hooks: Optional[LoggingHooks] = None,\n    headers: Optional[Dict[str, str]] = None,\n) -&gt; T3APIClient:\n    \"\"\"\n    Creates an authenticated T3 API client using an API key.\n\n    This function provides API key authentication by calling the /v2/auth/apikey\n    endpoint with the provided API key and state code.\n\n    Args:\n        api_key: T3 API key used for authentication via the /v2/auth/apikey endpoint.\n        state_code: Two-letter US state code for the target Metrc instance (e.g., \"CA\", \"MO\").\n        host: T3 API host URL. Defaults to production if no config provided.\n        config: HTTP configuration for timeout, SSL, and proxy settings.\n        retry_policy: Retry policy controlling backoff and max attempts for failed requests.\n        logging_hooks: Hooks for logging outgoing requests and incoming responses.\n        headers: Additional HTTP headers to include with every request.\n\n    Returns:\n        T3APIClient: An authenticated async client instance\n\n    Raises:\n        ValueError: If api_key or state_code is empty or None\n        AuthenticationError: If API key authentication fails\n\n    Example:\n        &gt;&gt;&gt; client = create_api_key_authenticated_client(\n        ...     api_key=\"your-api-key\",\n        ...     state_code=\"CA\"\n        ... )\n        &gt;&gt;&gt; # Client is ready to use for API calls (note: it's async)\n    \"\"\"\n    if not api_key or not api_key.strip():\n        raise ValueError(\"API key cannot be empty or None\")\n\n    if not state_code or not state_code.strip():\n        raise ValueError(\"State code cannot be empty or None\")\n\n    # Handle host and config parameters\n    if config is None:\n        # No config provided, create one with specified host or default\n        effective_host = host or config_manager.get_api_host()\n        config = HTTPConfig(host=effective_host)\n    elif host is not None and config.host != host:\n        # Config provided but different host explicitly specified\n        config = HTTPConfig(\n            host=host,\n            timeout=config.timeout,\n            verify_ssl=config.verify_ssl,\n            base_headers=config.base_headers,\n            proxies=config.proxies,\n        )\n    # Otherwise, use the provided config as-is\n\n    # Create the client\n    client = T3APIClient(\n        config=config,\n        retry_policy=retry_policy,\n        logging_hooks=logging_hooks,\n        headers=headers,\n    )\n\n    # Note: This function creates the client but doesn't authenticate it yet\n    # The caller needs to call authenticate_with_api_key() or use the high-level functions\n    return client\n</code></pre>"},{"location":"reference/auth/#t3api_utils.auth.utils.create_api_key_authenticated_client--client-is-ready-to-use-for-api-calls-note-its-async","title":"Client is ready to use for API calls (note: it's async)","text":""},{"location":"reference/auth/#t3api_utils.auth.utils.create_api_key_authenticated_client_or_error_async","title":"create_api_key_authenticated_client_or_error_async  <code>async</code>","text":"<pre><code>create_api_key_authenticated_client_or_error_async(*, api_key: str, state_code: str, host: Optional[str] = None) -&gt; T3APIClient\n</code></pre> <p>Authenticates with the T3 API using API key and returns an authenticated client (async).</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>T3 API key used for authentication via the /v2/auth/apikey endpoint.</p> required <code>state_code</code> <code>str</code> <p>Two-letter US state code for the target Metrc instance (e.g., \"CA\", \"MO\").</p> required <code>host</code> <code>Optional[str]</code> <p>T3 API host URL. Defaults to production if not provided.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>T3APIClient</code> <code>T3APIClient</code> <p>An authenticated async client instance ready for use</p> <p>Raises:</p> Type Description <code>AuthenticationError</code> <p>If authentication fails</p> Source code in <code>t3api_utils/auth/utils.py</code> <pre><code>async def create_api_key_authenticated_client_or_error_async(\n    *,\n    api_key: str,\n    state_code: str,\n    host: Optional[str] = None,\n) -&gt; T3APIClient:\n    \"\"\"\n    Authenticates with the T3 API using API key and returns an authenticated client (async).\n\n    Args:\n        api_key: T3 API key used for authentication via the /v2/auth/apikey endpoint.\n        state_code: Two-letter US state code for the target Metrc instance (e.g., \"CA\", \"MO\").\n        host: T3 API host URL. Defaults to production if not provided.\n\n    Returns:\n        T3APIClient: An authenticated async client instance ready for use\n\n    Raises:\n        AuthenticationError: If authentication fails\n    \"\"\"\n    try:\n        # Create HTTP config with host from config or parameter\n        effective_host = host or config_manager.get_api_host()\n        config = HTTPConfig(host=effective_host)\n\n        # Create and authenticate the client\n        client = T3APIClient(config=config)\n\n        await client.authenticate_with_api_key(\n            api_key=api_key,\n            state_code=state_code,\n        )\n\n        return client\n\n    except T3HTTPError as e:\n        raise AuthenticationError(f\"T3 API key authentication failed: {e}\") from e\n    except Exception as e:\n        raise AuthenticationError(f\"Unexpected API key authentication error: {str(e)}\") from e\n</code></pre>"},{"location":"reference/auth/#t3api_utils.auth.utils.create_api_key_authenticated_client_or_error","title":"create_api_key_authenticated_client_or_error","text":"<pre><code>create_api_key_authenticated_client_or_error(*, api_key: str, state_code: str, host: Optional[str] = None) -&gt; T3APIClient\n</code></pre> <p>Authenticates with the T3 API using API key and returns an authenticated client (sync wrapper).</p> <p>This function provides a sync wrapper around the async implementation.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>T3 API key used for authentication via the /v2/auth/apikey endpoint.</p> required <code>state_code</code> <code>str</code> <p>Two-letter US state code for the target Metrc instance (e.g., \"CA\", \"MO\").</p> required <code>host</code> <code>Optional[str]</code> <p>T3 API host URL. Defaults to production if not provided.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>T3APIClient</code> <code>T3APIClient</code> <p>An authenticated client instance ready for use</p> <p>Raises:</p> Type Description <code>AuthenticationError</code> <p>If authentication fails</p> Source code in <code>t3api_utils/auth/utils.py</code> <pre><code>def create_api_key_authenticated_client_or_error(\n    *,\n    api_key: str,\n    state_code: str,\n    host: Optional[str] = None,\n) -&gt; T3APIClient:\n    \"\"\"\n    Authenticates with the T3 API using API key and returns an authenticated client (sync wrapper).\n\n    This function provides a sync wrapper around the async implementation.\n\n    Args:\n        api_key: T3 API key used for authentication via the /v2/auth/apikey endpoint.\n        state_code: Two-letter US state code for the target Metrc instance (e.g., \"CA\", \"MO\").\n        host: T3 API host URL. Defaults to production if not provided.\n\n    Returns:\n        T3APIClient: An authenticated client instance ready for use\n\n    Raises:\n        AuthenticationError: If authentication fails\n    \"\"\"\n    return asyncio.run(create_api_key_authenticated_client_or_error_async(\n        api_key=api_key,\n        state_code=state_code,\n        host=host,\n    ))\n</code></pre>"},{"location":"reference/auth/#t3api_utils.auth.utils.authenticate_and_get_token_with_api_key_async","title":"authenticate_and_get_token_with_api_key_async  <code>async</code>","text":"<pre><code>authenticate_and_get_token_with_api_key_async(*, api_key: str, state_code: str, host: Optional[str] = None) -&gt; str\n</code></pre> <p>Authenticate with API key and return just the access token (async).</p> <p>This is a convenience function for when you only need the token and not the full client.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>T3 API key used for authentication via the /v2/auth/apikey endpoint.</p> required <code>state_code</code> <code>str</code> <p>Two-letter US state code for the target Metrc instance (e.g., \"CA\", \"MO\").</p> required <code>host</code> <code>Optional[str]</code> <p>T3 API host URL. Defaults to production if not provided.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The access token</p> <p>Raises:</p> Type Description <code>AuthenticationError</code> <p>If authentication fails</p> Source code in <code>t3api_utils/auth/utils.py</code> <pre><code>async def authenticate_and_get_token_with_api_key_async(\n    *,\n    api_key: str,\n    state_code: str,\n    host: Optional[str] = None,\n) -&gt; str:\n    \"\"\"\n    Authenticate with API key and return just the access token (async).\n\n    This is a convenience function for when you only need the token\n    and not the full client.\n\n    Args:\n        api_key: T3 API key used for authentication via the /v2/auth/apikey endpoint.\n        state_code: Two-letter US state code for the target Metrc instance (e.g., \"CA\", \"MO\").\n        host: T3 API host URL. Defaults to production if not provided.\n\n    Returns:\n        str: The access token\n\n    Raises:\n        AuthenticationError: If authentication fails\n    \"\"\"\n    client = await create_api_key_authenticated_client_or_error_async(\n        api_key=api_key,\n        state_code=state_code,\n        host=host,\n    )\n\n    if client.access_token is None:\n        raise AuthenticationError(\"API key authentication succeeded but no access token was returned\")\n\n    # Clean up the client\n    await client.close()\n\n    return client.access_token\n</code></pre>"},{"location":"reference/auth/#t3api_utils.auth.utils.authenticate_and_get_token_with_api_key","title":"authenticate_and_get_token_with_api_key","text":"<pre><code>authenticate_and_get_token_with_api_key(*, api_key: str, state_code: str, host: Optional[str] = None) -&gt; str\n</code></pre> <p>Authenticate with API key and return just the access token (sync wrapper).</p> <p>This is a convenience function for when you only need the token and not the full client.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>T3 API key used for authentication via the /v2/auth/apikey endpoint.</p> required <code>state_code</code> <code>str</code> <p>Two-letter US state code for the target Metrc instance (e.g., \"CA\", \"MO\").</p> required <code>host</code> <code>Optional[str]</code> <p>T3 API host URL. Defaults to production if not provided.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The access token</p> <p>Raises:</p> Type Description <code>AuthenticationError</code> <p>If authentication fails</p> Source code in <code>t3api_utils/auth/utils.py</code> <pre><code>def authenticate_and_get_token_with_api_key(\n    *,\n    api_key: str,\n    state_code: str,\n    host: Optional[str] = None,\n) -&gt; str:\n    \"\"\"\n    Authenticate with API key and return just the access token (sync wrapper).\n\n    This is a convenience function for when you only need the token\n    and not the full client.\n\n    Args:\n        api_key: T3 API key used for authentication via the /v2/auth/apikey endpoint.\n        state_code: Two-letter US state code for the target Metrc instance (e.g., \"CA\", \"MO\").\n        host: T3 API host URL. Defaults to production if not provided.\n\n    Returns:\n        str: The access token\n\n    Raises:\n        AuthenticationError: If authentication fails\n    \"\"\"\n    return asyncio.run(authenticate_and_get_token_with_api_key_async(\n        api_key=api_key,\n        state_code=state_code,\n        host=host,\n    ))\n</code></pre>"},{"location":"reference/auth/#t3api_utils.auth.utils.authenticate_and_get_response_with_api_key_async","title":"authenticate_and_get_response_with_api_key_async  <code>async</code>","text":"<pre><code>authenticate_and_get_response_with_api_key_async(*, api_key: str, state_code: str, host: Optional[str] = None) -&gt; AuthResponseData\n</code></pre> <p>Authenticate with API key and return the full authentication response (async).</p> <p>This function provides access to all authentication response data including refresh tokens and expiration information.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>T3 API key used for authentication via the /v2/auth/apikey endpoint.</p> required <code>state_code</code> <code>str</code> <p>Two-letter US state code for the target Metrc instance (e.g., \"CA\", \"MO\").</p> required <code>host</code> <code>Optional[str]</code> <p>T3 API host URL. Defaults to production if not provided.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>AuthResponseData</code> <code>AuthResponseData</code> <p>The complete authentication response</p> <p>Raises:</p> Type Description <code>AuthenticationError</code> <p>If authentication fails</p> Source code in <code>t3api_utils/auth/utils.py</code> <pre><code>async def authenticate_and_get_response_with_api_key_async(\n    *,\n    api_key: str,\n    state_code: str,\n    host: Optional[str] = None,\n) -&gt; AuthResponseData:\n    \"\"\"\n    Authenticate with API key and return the full authentication response (async).\n\n    This function provides access to all authentication response data\n    including refresh tokens and expiration information.\n\n    Args:\n        api_key: T3 API key used for authentication via the /v2/auth/apikey endpoint.\n        state_code: Two-letter US state code for the target Metrc instance (e.g., \"CA\", \"MO\").\n        host: T3 API host URL. Defaults to production if not provided.\n\n    Returns:\n        AuthResponseData: The complete authentication response\n\n    Raises:\n        AuthenticationError: If authentication fails\n    \"\"\"\n    try:\n        # Create HTTP config with host from config or parameter\n        effective_host = host or config_manager.get_api_host()\n        config = HTTPConfig(host=effective_host)\n\n        # Create client and authenticate\n        async with T3APIClient(config=config) as client:\n            auth_response = await client.authenticate_with_api_key(\n                api_key=api_key,\n                state_code=state_code,\n            )\n\n            return auth_response\n\n    except T3HTTPError as e:\n        raise AuthenticationError(f\"T3 API key authentication failed: {e}\") from e\n    except Exception as e:\n        raise AuthenticationError(f\"Unexpected API key authentication error: {str(e)}\") from e\n</code></pre>"},{"location":"reference/auth/#t3api_utils.auth.utils.authenticate_and_get_response_with_api_key","title":"authenticate_and_get_response_with_api_key","text":"<pre><code>authenticate_and_get_response_with_api_key(*, api_key: str, state_code: str, host: Optional[str] = None) -&gt; AuthResponseData\n</code></pre> <p>Authenticate with API key and return the full authentication response (sync wrapper).</p> <p>This function provides access to all authentication response data including refresh tokens and expiration information.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>T3 API key used for authentication via the /v2/auth/apikey endpoint.</p> required <code>state_code</code> <code>str</code> <p>Two-letter US state code for the target Metrc instance (e.g., \"CA\", \"MO\").</p> required <code>host</code> <code>Optional[str]</code> <p>T3 API host URL. Defaults to production if not provided.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>AuthResponseData</code> <code>AuthResponseData</code> <p>The complete authentication response</p> <p>Raises:</p> Type Description <code>AuthenticationError</code> <p>If authentication fails</p> Source code in <code>t3api_utils/auth/utils.py</code> <pre><code>def authenticate_and_get_response_with_api_key(\n    *,\n    api_key: str,\n    state_code: str,\n    host: Optional[str] = None,\n) -&gt; AuthResponseData:\n    \"\"\"\n    Authenticate with API key and return the full authentication response (sync wrapper).\n\n    This function provides access to all authentication response data\n    including refresh tokens and expiration information.\n\n    Args:\n        api_key: T3 API key used for authentication via the /v2/auth/apikey endpoint.\n        state_code: Two-letter US state code for the target Metrc instance (e.g., \"CA\", \"MO\").\n        host: T3 API host URL. Defaults to production if not provided.\n\n    Returns:\n        AuthResponseData: The complete authentication response\n\n    Raises:\n        AuthenticationError: If authentication fails\n    \"\"\"\n    return asyncio.run(authenticate_and_get_response_with_api_key_async(\n        api_key=api_key,\n        state_code=state_code,\n        host=host,\n    ))\n</code></pre>"},{"location":"reference/cli/","title":"CLI","text":""},{"location":"reference/cli/#constants","title":"Constants","text":""},{"location":"reference/cli/#t3api_utils.cli.consts","title":"consts","text":"<p>CLI constants and environment variable keys for t3api_utils configuration.</p> <p>Defines default values and the :class:<code>EnvKeys</code> enum whose members map to environment variables (and <code>.t3.env</code> file keys) that control authentication, HTTP behaviour, performance tuning, and output settings.</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.DEFAULT_OTP_WHITELIST","title":"DEFAULT_OTP_WHITELIST  <code>module-attribute</code>","text":"<pre><code>DEFAULT_OTP_WHITELIST = {'mi.metrc.com'}\n</code></pre> <p>Metrc hostnames that require a one-time password for authentication.</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.DEFAULT_CREDENTIAL_EMAIL_WHITELIST","title":"DEFAULT_CREDENTIAL_EMAIL_WHITELIST  <code>module-attribute</code>","text":"<pre><code>DEFAULT_CREDENTIAL_EMAIL_WHITELIST = {'co.metrc.com'}\n</code></pre> <p>Metrc hostnames that require an email address for authentication.</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.DEFAULT_T3_API_HOST","title":"DEFAULT_T3_API_HOST  <code>module-attribute</code>","text":"<pre><code>DEFAULT_T3_API_HOST = 'https://api.trackandtrace.tools'\n</code></pre> <p>Default base URL for the T3 API when no override is configured.</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.DEFAULT_ENV_PATH","title":"DEFAULT_ENV_PATH  <code>module-attribute</code>","text":"<pre><code>DEFAULT_ENV_PATH: Final[str] = '.t3.env'\n</code></pre> <p>Default path to the dotenv file where credentials and settings are persisted.</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys","title":"EnvKeys","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Environment variable keys recognised by :class:<code>t3api_utils.cli.utils.ConfigManager</code>.</p> <p>Each member's value is the literal env-var / dotenv key string. Members are grouped by concern: authentication, connection, performance, hostname behaviour, development, and output.</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.METRC_HOSTNAME","title":"METRC_HOSTNAME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>METRC_HOSTNAME = 'METRC_HOSTNAME'\n</code></pre> <p>Metrc state hostname (e.g. <code>ca.metrc.com</code>).</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.METRC_USERNAME","title":"METRC_USERNAME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>METRC_USERNAME = 'METRC_USERNAME'\n</code></pre> <p>Metrc account username.</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.METRC_PASSWORD","title":"METRC_PASSWORD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>METRC_PASSWORD = 'METRC_PASSWORD'\n</code></pre> <p>Metrc account password.</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.METRC_EMAIL","title":"METRC_EMAIL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>METRC_EMAIL = 'METRC_EMAIL'\n</code></pre> <p>Email address for hostnames that require it (see :data:<code>DEFAULT_CREDENTIAL_EMAIL_WHITELIST</code>).</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.JWT_TOKEN","title":"JWT_TOKEN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>JWT_TOKEN = 'JWT_TOKEN'\n</code></pre> <p>Pre-issued JWT bearer token for direct authentication.</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.API_KEY","title":"API_KEY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>API_KEY = 'API_KEY'\n</code></pre> <p>T3 API key for API-key-based authentication.</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.API_STATE_CODE","title":"API_STATE_CODE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>API_STATE_CODE = 'API_STATE_CODE'\n</code></pre> <p>Two-letter US state code associated with the API key.</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.T3_API_HOST","title":"T3_API_HOST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>T3_API_HOST = 'T3_API_HOST'\n</code></pre> <p>Base URL of the T3 API (overrides :data:<code>DEFAULT_T3_API_HOST</code>).</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.HTTP_TIMEOUT","title":"HTTP_TIMEOUT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HTTP_TIMEOUT = 'HTTP_TIMEOUT'\n</code></pre> <p>Overall HTTP request timeout in seconds.</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.HTTP_CONNECT_TIMEOUT","title":"HTTP_CONNECT_TIMEOUT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HTTP_CONNECT_TIMEOUT = 'HTTP_CONNECT_TIMEOUT'\n</code></pre> <p>TCP connection timeout in seconds.</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.HTTP_READ_TIMEOUT","title":"HTTP_READ_TIMEOUT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HTTP_READ_TIMEOUT = 'HTTP_READ_TIMEOUT'\n</code></pre> <p>HTTP response read timeout in seconds.</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.VERIFY_SSL","title":"VERIFY_SSL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VERIFY_SSL = 'VERIFY_SSL'\n</code></pre> <p>Whether to verify TLS certificates (<code>\"true\"</code> / <code>\"false\"</code>).</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.MAX_WORKERS","title":"MAX_WORKERS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAX_WORKERS = 'MAX_WORKERS'\n</code></pre> <p>Maximum number of parallel workers for concurrent data fetching.</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.BATCH_SIZE","title":"BATCH_SIZE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BATCH_SIZE = 'BATCH_SIZE'\n</code></pre> <p>Number of pages to fetch per batch in async parallel loading.</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.RATE_LIMIT_RPS","title":"RATE_LIMIT_RPS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RATE_LIMIT_RPS = 'RATE_LIMIT_RPS'\n</code></pre> <p>Maximum requests per second for the rate limiter.</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.RATE_LIMIT_BURST","title":"RATE_LIMIT_BURST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RATE_LIMIT_BURST = 'RATE_LIMIT_BURST'\n</code></pre> <p>Maximum burst size allowed by the rate limiter.</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.RETRY_MAX_ATTEMPTS","title":"RETRY_MAX_ATTEMPTS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RETRY_MAX_ATTEMPTS = 'RETRY_MAX_ATTEMPTS'\n</code></pre> <p>Maximum number of retry attempts for failed HTTP requests.</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.RETRY_BACKOFF_FACTOR","title":"RETRY_BACKOFF_FACTOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RETRY_BACKOFF_FACTOR = 'RETRY_BACKOFF_FACTOR'\n</code></pre> <p>Exponential backoff multiplier between retries.</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.RETRY_MIN_WAIT","title":"RETRY_MIN_WAIT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RETRY_MIN_WAIT = 'RETRY_MIN_WAIT'\n</code></pre> <p>Minimum wait time in seconds between retries.</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.OTP_WHITELIST","title":"OTP_WHITELIST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OTP_WHITELIST = 'OTP_WHITELIST'\n</code></pre> <p>Comma-separated list of hostnames requiring OTP authentication.</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.EMAIL_WHITELIST","title":"EMAIL_WHITELIST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMAIL_WHITELIST = 'EMAIL_WHITELIST'\n</code></pre> <p>Comma-separated list of hostnames requiring an email address.</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.OTP_SEED","title":"OTP_SEED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OTP_SEED = 'OTP_SEED'\n</code></pre> <p>TOTP seed for automatic one-time password generation.</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.LOG_LEVEL","title":"LOG_LEVEL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LOG_LEVEL = 'LOG_LEVEL'\n</code></pre> <p>Logging level (e.g. <code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>).</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.LOG_FORMAT","title":"LOG_FORMAT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LOG_FORMAT = 'LOG_FORMAT'\n</code></pre> <p>Custom log format string.</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.DEBUG_MODE","title":"DEBUG_MODE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEBUG_MODE = 'DEBUG_MODE'\n</code></pre> <p>Enable debug mode (<code>\"true\"</code> / <code>\"false\"</code>).</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.CACHE_RESPONSES","title":"CACHE_RESPONSES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CACHE_RESPONSES = 'CACHE_RESPONSES'\n</code></pre> <p>Cache API responses locally (<code>\"true\"</code> / <code>\"false\"</code>).</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.OUTPUT_DIR","title":"OUTPUT_DIR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OUTPUT_DIR = 'OUTPUT_DIR'\n</code></pre> <p>Directory for CSV/JSON output files.</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.TEMP_DIR","title":"TEMP_DIR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TEMP_DIR = 'TEMP_DIR'\n</code></pre> <p>Directory for temporary files.</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.AUTO_OPEN_FILES","title":"AUTO_OPEN_FILES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AUTO_OPEN_FILES = 'AUTO_OPEN_FILES'\n</code></pre> <p>Automatically open exported files after saving (<code>\"true\"</code> / <code>\"false\"</code>).</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.STRIP_EMPTY_COLUMNS","title":"STRIP_EMPTY_COLUMNS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STRIP_EMPTY_COLUMNS = 'STRIP_EMPTY_COLUMNS'\n</code></pre> <p>Remove columns that are entirely empty from CSV output (<code>\"true\"</code> / <code>\"false\"</code>).</p>"},{"location":"reference/cli/#t3api_utils.cli.consts.EnvKeys.DEFAULT_FILE_FORMAT","title":"DEFAULT_FILE_FORMAT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEFAULT_FILE_FORMAT = 'DEFAULT_FILE_FORMAT'\n</code></pre> <p>Default export format (<code>\"csv\"</code> or <code>\"json\"</code>).</p>"},{"location":"reference/cli/#utilities","title":"Utilities","text":""},{"location":"reference/cli/#t3api_utils.cli.utils","title":"utils","text":"<p>CLI utility functions for configuration management and authentication.</p> <p>Provides the <code>ConfigManager</code> class for reading and auto-generating the <code>.t3.env</code> configuration file, as well as helper functions for loading, prompting, and persisting Metrc credentials.</p>"},{"location":"reference/cli/#t3api_utils.cli.utils.DEFAULT_ENV_PATH","title":"DEFAULT_ENV_PATH  <code>module-attribute</code>","text":"<pre><code>DEFAULT_ENV_PATH: Final[str] = '.t3.env'\n</code></pre> <p>Default path to the dotenv file where credentials and settings are persisted.</p>"},{"location":"reference/cli/#t3api_utils.cli.utils.ConfigManager","title":"ConfigManager","text":"<pre><code>ConfigManager(config_path: str = DEFAULT_ENV_PATH)\n</code></pre> <p>Centralized configuration manager for .t3.env file.</p> <p>Handles auto-generation, validation, and reading of the comprehensive .t3.env configuration file with all t3api-utils settings.</p> <p>Initialize the configuration manager.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>str</code> <p>Filesystem path to the <code>.t3.env</code> configuration file. Defaults to <code>DEFAULT_ENV_PATH</code>.</p> <code>DEFAULT_ENV_PATH</code> Source code in <code>t3api_utils/cli/utils.py</code> <pre><code>def __init__(self, config_path: str = DEFAULT_ENV_PATH):\n    \"\"\"Initialize the configuration manager.\n\n    Args:\n        config_path: Filesystem path to the ``.t3.env`` configuration\n            file. Defaults to ``DEFAULT_ENV_PATH``.\n    \"\"\"\n    self.config_path = config_path\n    self._config_cache: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"reference/cli/#t3api_utils.cli.utils.ConfigManager.ensure_config_exists","title":"ensure_config_exists","text":"<pre><code>ensure_config_exists() -&gt; None\n</code></pre> <p>Ensure <code>.t3.env</code> exists and is complete, auto-generating if needed.</p> <p>Creates the configuration file when it is missing or regenerates it when required keys are absent. Prints an info message when the file is generated or updated.</p> Source code in <code>t3api_utils/cli/utils.py</code> <pre><code>def ensure_config_exists(self) -&gt; None:\n    \"\"\"Ensure ``.t3.env`` exists and is complete, auto-generating if needed.\n\n    Creates the configuration file when it is missing or regenerates it\n    when required keys are absent. Prints an info message when the file\n    is generated or updated.\n    \"\"\"\n    if not self._config_exists() or self._needs_update():\n        self._generate_config_file()\n        print_info(f\"Generated/updated {self.config_path} configuration file\")\n</code></pre>"},{"location":"reference/cli/#t3api_utils.cli.utils.ConfigManager.get_config_value","title":"get_config_value","text":"<pre><code>get_config_value(key: EnvKeys, default: Any = None) -&gt; Any\n</code></pre> <p>Get a configuration value with automatic type conversion.</p> <p>Loads the configuration file, reads the requested key, and converts the raw string to the appropriate Python type (bool, float, int, or set) based on the key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>EnvKeys</code> <p>The <code>EnvKeys</code> member identifying the configuration value.</p> required <code>default</code> <code>Any</code> <p>Fallback value returned when the key is missing or type conversion fails.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The converted configuration value, or <code>default</code> if the key is</p> <code>Any</code> <p>absent or conversion fails.</p> Source code in <code>t3api_utils/cli/utils.py</code> <pre><code>def get_config_value(self, key: EnvKeys, default: Any = None) -&gt; Any:\n    \"\"\"Get a configuration value with automatic type conversion.\n\n    Loads the configuration file, reads the requested key, and converts\n    the raw string to the appropriate Python type (bool, float, int, or\n    set) based on the key.\n\n    Args:\n        key: The ``EnvKeys`` member identifying the configuration value.\n        default: Fallback value returned when the key is missing or\n            type conversion fails.\n\n    Returns:\n        The converted configuration value, or ``default`` if the key is\n        absent or conversion fails.\n    \"\"\"\n    load_dotenv(dotenv_path=self.config_path)\n    value = os.getenv(key.value)\n\n    if value is None:\n        return default\n\n    # Type conversion based on key\n    if key in [EnvKeys.DEBUG_MODE, EnvKeys.VERIFY_SSL, EnvKeys.AUTO_OPEN_FILES,\n               EnvKeys.STRIP_EMPTY_COLUMNS, EnvKeys.CACHE_RESPONSES]:\n        return value.lower() in ['true', '1', 'yes', 'on']\n    elif key in [EnvKeys.HTTP_TIMEOUT, EnvKeys.HTTP_CONNECT_TIMEOUT, EnvKeys.HTTP_READ_TIMEOUT,\n                 EnvKeys.RETRY_BACKOFF_FACTOR, EnvKeys.RETRY_MIN_WAIT]:\n        try:\n            return float(value)\n        except ValueError:\n            return default\n    elif key in [EnvKeys.MAX_WORKERS, EnvKeys.BATCH_SIZE, EnvKeys.RATE_LIMIT_RPS,\n                 EnvKeys.RATE_LIMIT_BURST, EnvKeys.RETRY_MAX_ATTEMPTS]:\n        try:\n            return int(value)\n        except ValueError:\n            return default\n    elif key in [EnvKeys.OTP_WHITELIST, EnvKeys.EMAIL_WHITELIST]:\n        # Convert comma-separated string to set\n        return {hostname.strip() for hostname in value.split(',') if hostname.strip()}\n\n    return value\n</code></pre>"},{"location":"reference/cli/#t3api_utils.cli.utils.ConfigManager.get_otp_whitelist","title":"get_otp_whitelist","text":"<pre><code>get_otp_whitelist() -&gt; Set[str]\n</code></pre> <p>Get the set of hostnames that require OTP authentication.</p> <p>Returns:</p> Type Description <code>Set[str]</code> <p>Set of Metrc hostnames requiring OTP, falling back to</p> <code>Set[str]</code> <p><code>DEFAULT_OTP_WHITELIST</code> when unconfigured.</p> Source code in <code>t3api_utils/cli/utils.py</code> <pre><code>def get_otp_whitelist(self) -&gt; Set[str]:\n    \"\"\"Get the set of hostnames that require OTP authentication.\n\n    Returns:\n        Set of Metrc hostnames requiring OTP, falling back to\n        ``DEFAULT_OTP_WHITELIST`` when unconfigured.\n    \"\"\"\n    whitelist = self.get_config_value(EnvKeys.OTP_WHITELIST)\n    return whitelist if whitelist else DEFAULT_OTP_WHITELIST\n</code></pre>"},{"location":"reference/cli/#t3api_utils.cli.utils.ConfigManager.get_email_whitelist","title":"get_email_whitelist","text":"<pre><code>get_email_whitelist() -&gt; Set[str]\n</code></pre> <p>Get the set of hostnames that require an email during authentication.</p> <p>Returns:</p> Type Description <code>Set[str]</code> <p>Set of Metrc hostnames requiring email, falling back to</p> <code>Set[str]</code> <p><code>DEFAULT_CREDENTIAL_EMAIL_WHITELIST</code> when unconfigured.</p> Source code in <code>t3api_utils/cli/utils.py</code> <pre><code>def get_email_whitelist(self) -&gt; Set[str]:\n    \"\"\"Get the set of hostnames that require an email during authentication.\n\n    Returns:\n        Set of Metrc hostnames requiring email, falling back to\n        ``DEFAULT_CREDENTIAL_EMAIL_WHITELIST`` when unconfigured.\n    \"\"\"\n    whitelist = self.get_config_value(EnvKeys.EMAIL_WHITELIST)\n    return whitelist if whitelist else DEFAULT_CREDENTIAL_EMAIL_WHITELIST\n</code></pre>"},{"location":"reference/cli/#t3api_utils.cli.utils.ConfigManager.get_api_host","title":"get_api_host","text":"<pre><code>get_api_host() -&gt; str\n</code></pre> <p>Get the T3 API base URL.</p> <p>Returns:</p> Type Description <code>str</code> <p>The configured API host string, falling back to</p> <code>str</code> <p><code>DEFAULT_T3_API_HOST</code> when unconfigured.</p> Source code in <code>t3api_utils/cli/utils.py</code> <pre><code>def get_api_host(self) -&gt; str:\n    \"\"\"Get the T3 API base URL.\n\n    Returns:\n        The configured API host string, falling back to\n        ``DEFAULT_T3_API_HOST`` when unconfigured.\n    \"\"\"\n    host = self.get_config_value(EnvKeys.T3_API_HOST)\n    return host if host else DEFAULT_T3_API_HOST\n</code></pre>"},{"location":"reference/cli/#t3api_utils.cli.utils.ConfigManager.get_otp_seed","title":"get_otp_seed","text":"<pre><code>get_otp_seed() -&gt; Optional[str]\n</code></pre> <p>Get the Base32-encoded OTP seed for TOTP generation.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The trimmed seed string, or <code>None</code> if the seed is not</p> <code>Optional[str]</code> <p>configured or is empty.</p> Source code in <code>t3api_utils/cli/utils.py</code> <pre><code>def get_otp_seed(self) -&gt; Optional[str]:\n    \"\"\"Get the Base32-encoded OTP seed for TOTP generation.\n\n    Returns:\n        The trimmed seed string, or ``None`` if the seed is not\n        configured or is empty.\n    \"\"\"\n    seed = self.get_config_value(EnvKeys.OTP_SEED)\n    return seed.strip() if seed else None\n</code></pre>"},{"location":"reference/cli/#t3api_utils.cli.utils.generate_otp_from_seed","title":"generate_otp_from_seed","text":"<pre><code>generate_otp_from_seed() -&gt; Optional[str]\n</code></pre> <p>Generate a 6-digit TOTP code from the OTP_SEED environment variable.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>6-digit OTP string if OTP_SEED is configured, None otherwise.</p> <p>Raises:</p> Type Description <code>AuthenticationError</code> <p>If OTP_SEED is malformed or TOTP generation fails.</p> Source code in <code>t3api_utils/cli/utils.py</code> <pre><code>def generate_otp_from_seed() -&gt; Optional[str]:\n    \"\"\"\n    Generate a 6-digit TOTP code from the OTP_SEED environment variable.\n\n    Returns:\n        6-digit OTP string if OTP_SEED is configured, None otherwise.\n\n    Raises:\n        AuthenticationError: If OTP_SEED is malformed or TOTP generation fails.\n    \"\"\"\n    otp_seed = config_manager.get_otp_seed()\n    if not otp_seed:\n        return None\n\n    try:\n        totp = pyotp.TOTP(otp_seed)\n        otp_code = totp.now()\n\n        # Ensure it's always 6 digits (pad with zeros if needed)\n        return f\"{int(otp_code):06d}\"\n\n    except Exception as e:\n        raise AuthenticationError(f\"Failed to generate OTP from seed: {e}\")\n</code></pre>"},{"location":"reference/cli/#t3api_utils.cli.utils.load_credentials_from_env","title":"load_credentials_from_env","text":"<pre><code>load_credentials_from_env() -&gt; Dict[str, str]\n</code></pre> <p>Load credential values from the <code>.t3.env</code> environment file.</p> <p>Reads all available authentication values including Metrc credentials, JWT tokens, and API key credentials. Only non-empty values are included in the returned dictionary.</p> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Dictionary mapping credential names (e.g. <code>\"hostname\"</code>,</p> <code>Dict[str, str]</code> <p><code>\"username\"</code>, <code>\"jwt_token\"</code>) to their string values.</p> <code>Dict[str, str]</code> <p>Keys with empty or missing values are omitted.</p> Source code in <code>t3api_utils/cli/utils.py</code> <pre><code>def load_credentials_from_env() -&gt; Dict[str, str]:\n    \"\"\"Load credential values from the ``.t3.env`` environment file.\n\n    Reads all available authentication values including Metrc credentials,\n    JWT tokens, and API key credentials. Only non-empty values are included\n    in the returned dictionary.\n\n    Returns:\n        Dictionary mapping credential names (e.g. ``\"hostname\"``,\n        ``\"username\"``, ``\"jwt_token\"``) to their string values.\n        Keys with empty or missing values are omitted.\n    \"\"\"\n    load_dotenv(dotenv_path=DEFAULT_ENV_PATH)\n\n    creds = {}\n\n    # Metrc credentials\n    hostname = (os.getenv(EnvKeys.METRC_HOSTNAME.value) or \"\").strip()\n    username = (os.getenv(EnvKeys.METRC_USERNAME.value) or \"\").strip()\n    password = (os.getenv(EnvKeys.METRC_PASSWORD.value) or \"\").strip()\n    email = (os.getenv(EnvKeys.METRC_EMAIL.value) or \"\").strip()\n\n    # Alternative authentication methods\n    jwt_token = (os.getenv(EnvKeys.JWT_TOKEN.value) or \"\").strip()\n    api_key = (os.getenv(EnvKeys.API_KEY.value) or \"\").strip()\n    api_state_code = (os.getenv(EnvKeys.API_STATE_CODE.value) or \"\").strip()\n\n    if hostname:\n        creds[\"hostname\"] = hostname\n    if username:\n        creds[\"username\"] = username\n    if password:\n        creds[\"password\"] = password\n    if email:\n        creds[\"email\"] = email\n    if jwt_token:\n        creds[\"jwt_token\"] = jwt_token\n    if api_key:\n        creds[\"api_key\"] = api_key\n    if api_state_code:\n        creds[\"api_state_code\"] = api_state_code\n\n    return creds\n</code></pre>"},{"location":"reference/cli/#t3api_utils.cli.utils.offer_to_save_credentials","title":"offer_to_save_credentials","text":"<pre><code>offer_to_save_credentials(*, credentials: T3Credentials) -&gt; None\n</code></pre> <p>Offer to save credentials to the <code>.t3.env</code> file.</p> <p>If the environment file does not exist, the user is prompted to create it. If it exists but any credential values differ from those provided, the user is prompted to update the file.</p> <p>Parameters:</p> Name Type Description Default <code>credentials</code> <code>T3Credentials</code> <p>The <code>T3Credentials</code> dictionary containing the current authentication values to compare and potentially save.</p> required Source code in <code>t3api_utils/cli/utils.py</code> <pre><code>def offer_to_save_credentials(*, credentials: T3Credentials) -&gt; None:\n    \"\"\"Offer to save credentials to the ``.t3.env`` file.\n\n    If the environment file does not exist, the user is prompted to create\n    it. If it exists but any credential values differ from those provided,\n    the user is prompted to update the file.\n\n    Args:\n        credentials: The ``T3Credentials`` dictionary containing the\n            current authentication values to compare and potentially save.\n    \"\"\"\n    load_dotenv(dotenv_path=DEFAULT_ENV_PATH)\n    env_exists = os.path.exists(DEFAULT_ENV_PATH)\n\n    current_hostname = os.getenv(EnvKeys.METRC_HOSTNAME.value, \"\").strip()\n    current_username = os.getenv(EnvKeys.METRC_USERNAME.value, \"\").strip()\n    current_password = os.getenv(EnvKeys.METRC_PASSWORD.value, \"\").strip()\n    current_email = os.getenv(EnvKeys.METRC_EMAIL.value, \"\").strip()\n\n    hostname_differs = credentials[\"hostname\"] != current_hostname\n    username_differs = credentials[\"username\"] != current_username\n    password_differs = credentials[\"password\"] != current_password\n\n    # Only check email differences if the hostname requires email\n    email_differs = False\n    if credentials[\"hostname\"] in config_manager.get_email_whitelist():\n        email_differs = credentials.get(\"email\") != current_email\n\n    if not env_exists:\n        if typer.confirm(\n            f\"No credentials file found. Save these values to {DEFAULT_ENV_PATH}?\",\n            default=True,\n        ):\n            logger.info(\"[green]Saving credentials to new environment file.[/green]\")\n            set_key(\n                DEFAULT_ENV_PATH, EnvKeys.METRC_HOSTNAME.value, credentials[\"hostname\"]\n            )\n            set_key(\n                DEFAULT_ENV_PATH, EnvKeys.METRC_USERNAME.value, credentials[\"username\"]\n            )\n            set_key(\n                DEFAULT_ENV_PATH, EnvKeys.METRC_PASSWORD.value, credentials[\"password\"]\n            )\n            email_value = credentials.get(\"email\")\n            if email_value:\n                set_key(\n                    DEFAULT_ENV_PATH, EnvKeys.METRC_EMAIL.value, email_value\n                )\n    elif hostname_differs or username_differs or password_differs or email_differs:\n        if typer.confirm(\n            f\"Some credential values differ from those in {DEFAULT_ENV_PATH}. Update them?\",\n            default=True,\n        ):\n            logger.info(\"[cyan]Updating credentials in environment file.[/cyan]\")\n            set_key(\n                DEFAULT_ENV_PATH, EnvKeys.METRC_HOSTNAME.value, credentials[\"hostname\"]\n            )\n            set_key(\n                DEFAULT_ENV_PATH, EnvKeys.METRC_USERNAME.value, credentials[\"username\"]\n            )\n            set_key(\n                DEFAULT_ENV_PATH, EnvKeys.METRC_PASSWORD.value, credentials[\"password\"]\n            )\n            email_value = credentials.get(\"email\")\n            if email_value:\n                set_key(\n                    DEFAULT_ENV_PATH, EnvKeys.METRC_EMAIL.value, email_value\n                )\n</code></pre>"},{"location":"reference/cli/#t3api_utils.cli.utils.prompt_for_credentials_or_error","title":"prompt_for_credentials_or_error","text":"<pre><code>prompt_for_credentials_or_error(**kwargs: object) -&gt; T3Credentials\n</code></pre> <p>Prompt for any missing credentials, using provided values if available.</p> <p>Pre-populated values (typically loaded from the environment) are used without prompting. Missing values are requested interactively. OTP and email prompts are shown only when the hostname requires them.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>object</code> <p>Optional pre-populated credential values. Recognized keys are <code>hostname</code>, <code>username</code>, <code>password</code>, and <code>email</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>T3Credentials</code> <p>A fully-populated <code>T3Credentials</code> dictionary.</p> <p>Raises:</p> Type Description <code>AuthenticationError</code> <p>If a required credential is missing or empty, the OTP code is invalid, or the email address is malformed.</p> Source code in <code>t3api_utils/cli/utils.py</code> <pre><code>def prompt_for_credentials_or_error(**kwargs: object) -&gt; T3Credentials:\n    \"\"\"Prompt for any missing credentials, using provided values if available.\n\n    Pre-populated values (typically loaded from the environment) are used\n    without prompting. Missing values are requested interactively. OTP and\n    email prompts are shown only when the hostname requires them.\n\n    Args:\n        **kwargs: Optional pre-populated credential values. Recognized keys\n            are ``hostname``, ``username``, ``password``, and ``email``.\n\n    Returns:\n        A fully-populated ``T3Credentials`` dictionary.\n\n    Raises:\n        AuthenticationError: If a required credential is missing or empty,\n            the OTP code is invalid, or the email address is malformed.\n    \"\"\"\n    hostname = str(kwargs.get(\"hostname\", \"\")) if kwargs.get(\"hostname\") else None\n    username = str(kwargs.get(\"username\", \"\")) if kwargs.get(\"username\") else None\n    password = str(kwargs.get(\"password\", \"\")) if kwargs.get(\"password\") else None\n    email = str(kwargs.get(\"email\", \"\")) if kwargs.get(\"email\") else None\n\n    if hostname:\n        print_info(f\"Using stored value for hostname: {hostname}\")\n    else:\n        hostname = typer.prompt(\"Enter Metrc hostname (e.g., mo.metrc.com)\")\n\n    if username:\n        print_info(f\"Using stored value for username: {username}\")\n    else:\n        username = typer.prompt(\"Enter Metrc username\")\n\n    if password:\n        print_info(\"Using stored value for password.\")\n    else:\n        password = typer.prompt(\"Enter Metrc password\", hide_input=True)\n\n    credentials: T3Credentials = {\n        \"hostname\": hostname or \"\",\n        \"username\": username or \"\",\n        \"password\": password or \"\",\n        \"otp\": None,\n        \"email\": None,\n    }\n\n    if hostname in config_manager.get_otp_whitelist():\n        # Try to generate OTP from seed first, otherwise prompt user\n        otp = generate_otp_from_seed()\n        if otp:\n            print_info(\"Using OTP generated from configured seed\")\n            credentials[\"otp\"] = otp\n        else:\n            otp = typer.prompt(\"Enter 6-digit Metrc 2-factor authentication code\")\n            if not otp or len(otp) != 6 or not otp.isdigit():\n                print_error(\"Invalid 2-factor authentication entered.\")\n                raise AuthenticationError(f\"Invalid 2-factor authentication: {otp}\")\n            credentials[\"otp\"] = otp\n\n    if hostname in config_manager.get_email_whitelist():\n        if email:\n            print_info(f\"Using stored value for email: {email}\")\n            credentials[\"email\"] = email\n        else:\n            email_input = typer.prompt(\"Enter Metrc email address\")\n            if not email_input or \"@\" not in email_input:\n                print_error(\"Invalid email address entered.\")\n                raise AuthenticationError(f\"Invalid email address: {email_input}\")\n            credentials[\"email\"] = email_input\n\n    for key, value in credentials.items():\n        if key not in (\"otp\", \"email\") and (not isinstance(value, str) or not value.strip()):\n            print_error(f\"Missing or empty credential: {key}\")\n            raise AuthenticationError(f\"Missing or empty credential: {key}\")\n\n    return credentials\n</code></pre>"},{"location":"reference/cli/#t3api_utils.cli.utils.resolve_auth_inputs_or_error","title":"resolve_auth_inputs_or_error","text":"<pre><code>resolve_auth_inputs_or_error() -&gt; T3Credentials\n</code></pre> <p>Resolve authentication credentials from env and/or interactive prompt.</p> <p>Loads any stored credentials from the environment file, prompts the user for missing values, and offers to persist the final set back to the <code>.t3.env</code> file.</p> <p>Returns:</p> Type Description <code>T3Credentials</code> <p>A fully-populated <code>T3Credentials</code> dictionary ready for use with</p> <code>T3Credentials</code> <p>the authentication client.</p> <p>Raises:</p> Type Description <code>AuthenticationError</code> <p>If required credentials cannot be resolved (propagated from <code>prompt_for_credentials_or_error</code>).</p> Source code in <code>t3api_utils/cli/utils.py</code> <pre><code>def resolve_auth_inputs_or_error() -&gt; T3Credentials:\n    \"\"\"Resolve authentication credentials from env and/or interactive prompt.\n\n    Loads any stored credentials from the environment file, prompts the\n    user for missing values, and offers to persist the final set back to\n    the ``.t3.env`` file.\n\n    Returns:\n        A fully-populated ``T3Credentials`` dictionary ready for use with\n        the authentication client.\n\n    Raises:\n        AuthenticationError: If required credentials cannot be resolved\n            (propagated from ``prompt_for_credentials_or_error``).\n    \"\"\"\n    print_subheader(\"Authentication Required\")\n    stored_credentials = load_credentials_from_env()\n    credentials = prompt_for_credentials_or_error(**stored_credentials)\n    offer_to_save_credentials(credentials=credentials)\n    return credentials\n</code></pre>"},{"location":"reference/collection/","title":"Collection","text":""},{"location":"reference/collection/#t3api_utils.collection.utils","title":"utils","text":"<p>Collection utilities for parallel API data loading.</p> <p>This module provides both legacy and enhanced parallel loading capabilities, supporting both the original t3api-based functions and new httpx-based clients.</p>"},{"location":"reference/collection/#t3api_utils.collection.utils.parallel_load_collection","title":"parallel_load_collection","text":"<pre><code>parallel_load_collection(method: Callable[P, MetrcCollectionResponse], max_workers: int | None = None, *args: args, **kwargs: kwargs) -&gt; List[MetrcCollectionResponse]\n</code></pre> <p>Fetch paginated responses in parallel using a thread pool.</p> <p>Makes an initial request to determine total records and page size, then fetches all remaining pages concurrently via a thread pool executor.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Callable[P, MetrcCollectionResponse]</code> <p>A callable that returns a <code>MetrcCollectionResponse</code>. Must accept a <code>page</code> keyword argument for pagination.</p> required <code>max_workers</code> <code>int | None</code> <p>Maximum number of threads for concurrent fetching. Passed directly to <code>ThreadPoolExecutor</code>; <code>None</code> lets the executor choose a default.</p> <code>None</code> <code>*args</code> <code>args</code> <p>Positional arguments forwarded to <code>method</code>.</p> <code>()</code> <code>**kwargs</code> <code>kwargs</code> <p>Keyword arguments forwarded to <code>method</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[MetrcCollectionResponse]</code> <p>A list of <code>MetrcCollectionResponse</code> objects, one per page, ordered</p> <code>List[MetrcCollectionResponse]</code> <p>by page number.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the first response is missing the <code>total</code> field or the page size cannot be determined (missing or zero).</p> Source code in <code>t3api_utils/collection/utils.py</code> <pre><code>def parallel_load_collection(\n    method: Callable[P, MetrcCollectionResponse],\n    max_workers: int | None = None,\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; List[MetrcCollectionResponse]:\n    \"\"\"Fetch paginated responses in parallel using a thread pool.\n\n    Makes an initial request to determine total records and page size, then\n    fetches all remaining pages concurrently via a thread pool executor.\n\n    Args:\n        method: A callable that returns a ``MetrcCollectionResponse``. Must\n            accept a ``page`` keyword argument for pagination.\n        max_workers: Maximum number of threads for concurrent fetching.\n            Passed directly to ``ThreadPoolExecutor``; ``None`` lets the\n            executor choose a default.\n        *args: Positional arguments forwarded to ``method``.\n        **kwargs: Keyword arguments forwarded to ``method``.\n\n    Returns:\n        A list of ``MetrcCollectionResponse`` objects, one per page, ordered\n        by page number.\n\n    Raises:\n        ValueError: If the first response is missing the ``total`` field or\n            the page size cannot be determined (missing or zero).\n    \"\"\"\n    logger.info(\"Starting parallel data load\")\n    first_response = method(*args, **kwargs)\n\n    if first_response[\"total\"] is None:\n        raise ValueError(\"Response missing required `total` attribute.\")\n\n    total = first_response[\"total\"]\n    responses: List[MetrcCollectionResponse | None] = [None] * 1  # seed with first response\n\n    page_size = first_response.get(\"pageSize\")\n    if page_size is None:\n        page_size = len(first_response[\"data\"])\n    if page_size is None or page_size == 0:\n        raise ValueError(\"Unable to determine page size from first response.\")\n\n    num_pages = (total + page_size - 1) // page_size\n    logger.info(\n        f\"Total records: {total}, page size: {page_size}, total pages: {num_pages}\"\n    )\n\n    responses = [None] * num_pages\n    responses[0] = first_response\n\n    def fetch_page(page_number: int) -&gt; tuple[int, MetrcCollectionResponse]:\n        logger.debug(f\"Fetching page {page_number + 1}\")\n        response = method(*args, **kwargs, page=page_number + 1)  # type: ignore\n        return page_number, response\n\n    with ThreadPoolExecutor(max_workers=max_workers) as executor:\n        futures = [executor.submit(fetch_page, i) for i in range(1, num_pages)]\n        for count, future in enumerate(as_completed(futures), start=1):\n            page_number, response = future.result()\n            responses[page_number] = response\n            logger.info(f\"Loaded page {page_number + 1} ({count}/{num_pages - 1})\")\n\n    logger.info(\"Finished loading all pages\")\n    return [r for r in responses if r is not None]\n</code></pre>"},{"location":"reference/collection/#t3api_utils.collection.utils.extract_data","title":"extract_data","text":"<pre><code>extract_data(*, responses: List[MetrcCollectionResponse]) -&gt; List[MetrcObject]\n</code></pre> <p>Flatten a list of MetrcCollectionResponse objects that each have a <code>.data</code> property into a single list of MetrcObject items.</p> <p>Parameters:</p> Name Type Description Default <code>responses</code> <code>List[MetrcCollectionResponse]</code> <p>A list of MetrcCollectionResponse objects.</p> required <p>Returns:</p> Type Description <code>List[MetrcObject]</code> <p>List[MetrcObject]: A flattened list of all items from the <code>.data</code> attributes.</p> Example <p>extract_data([Response1(data=[1, 2]), Response2(data=[3])]) [1, 2, 3]</p> Source code in <code>t3api_utils/collection/utils.py</code> <pre><code>def extract_data(*, responses: List[MetrcCollectionResponse]) -&gt; List[MetrcObject]:\n    \"\"\"\n    Flatten a list of MetrcCollectionResponse objects that each have a `.data` property\n    into a single list of MetrcObject items.\n\n    Args:\n        responses: A list of MetrcCollectionResponse objects.\n\n    Returns:\n        List[MetrcObject]: A flattened list of all items from the `.data` attributes.\n\n    Example:\n        &gt;&gt;&gt; extract_data([Response1(data=[1, 2]), Response2(data=[3])])\n        [1, 2, 3]\n    \"\"\"\n    # Use nested list comprehension to flatten all `.data` lists into one\n    return [item for response in responses for item in response[\"data\"]]\n</code></pre>"},{"location":"reference/db/","title":"Database","text":""},{"location":"reference/db/#t3api_utils.db.utils","title":"utils","text":"<p>Database utilities for DuckDB table creation, schema export, and nested data extraction.</p>"},{"location":"reference/db/#t3api_utils.db.utils.create_duckdb_connection","title":"create_duckdb_connection","text":"<pre><code>create_duckdb_connection(*, database: str = ':memory:', read_only: bool = False) -&gt; duckdb.DuckDBPyConnection\n</code></pre> <p>Creates and returns a DuckDB connection with configurable settings.</p> <p>This provides a centralized way to create DuckDB connections that can be extended with additional configuration options as needed.</p> <p>Parameters:</p> Name Type Description Default <code>database</code> <code>str</code> <p>Database path or \":memory:\" for in-memory database (default: \":memory:\")</p> <code>':memory:'</code> <code>read_only</code> <code>bool</code> <p>Whether to open the database in read-only mode (default: False)</p> <code>False</code> <p>Returns:</p> Type Description <code>DuckDBPyConnection</code> <p>DuckDB connection object</p> Example <p>con = create_duckdb_connection()  # In-memory database con = create_duckdb_connection(database=\"mydata.db\")  # File-based database con = create_duckdb_connection(database=\"mydata.db\", read_only=True)  # Read-only</p> Source code in <code>t3api_utils/db/utils.py</code> <pre><code>def create_duckdb_connection(\n    *,\n    database: str = \":memory:\",\n    read_only: bool = False,\n) -&gt; duckdb.DuckDBPyConnection:\n    \"\"\"\n    Creates and returns a DuckDB connection with configurable settings.\n\n    This provides a centralized way to create DuckDB connections that can be\n    extended with additional configuration options as needed.\n\n    Args:\n        database: Database path or \":memory:\" for in-memory database (default: \":memory:\")\n        read_only: Whether to open the database in read-only mode (default: False)\n\n    Returns:\n        DuckDB connection object\n\n    Example:\n        &gt;&gt;&gt; con = create_duckdb_connection()  # In-memory database\n        &gt;&gt;&gt; con = create_duckdb_connection(database=\"mydata.db\")  # File-based database\n        &gt;&gt;&gt; con = create_duckdb_connection(database=\"mydata.db\", read_only=True)  # Read-only\n    \"\"\"\n    return duckdb.connect(database=database, read_only=read_only)\n</code></pre>"},{"location":"reference/db/#t3api_utils.db.utils.flatten_and_extract","title":"flatten_and_extract","text":"<pre><code>flatten_and_extract(*, data: List[Dict[str, Any]], extracted_tables: Dict[str, Dict[Any, Dict[str, Any]]]) -&gt; List[Dict[str, Any]]\n</code></pre> <p>Flattens nested records and extracts referenced dicts and lists of dicts into separate tables.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>List[Dict[str, Any]]</code> <p>A list of top-level dictionaries containing nested dicts and/or lists.</p> required <code>extracted_tables</code> <code>Dict[str, Dict[Any, Dict[str, Any]]]</code> <p>A dictionary to collect deduplicated records by table name.</p> required <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>A list of flattened dictionaries with references to nested entities via foreign keys.</p> Source code in <code>t3api_utils/db/utils.py</code> <pre><code>def flatten_and_extract(\n    *,\n    data: List[Dict[str, Any]],\n    extracted_tables: Dict[str, Dict[Any, Dict[str, Any]]],\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Flattens nested records and extracts referenced dicts and lists of dicts into separate tables.\n\n    Args:\n        data: A list of top-level dictionaries containing nested dicts and/or lists.\n        extracted_tables: A dictionary to collect deduplicated records by table name.\n\n    Returns:\n        A list of flattened dictionaries with references to nested entities via foreign keys.\n    \"\"\"\n    flat_data: List[Dict[str, Any]] = []\n\n    for record in data:\n        flat_record = {}\n        parent_id = record.get(ID_KEY)\n        parent_model = record.get(MODEL_KEY)\n\n        for key, value in record.items():\n            # if _is_nested_dict(value):\n            #     _extract_nested_dict(value, flat_record, extracted_tables)\n\n            # elif\n            if (\n                _is_list_of_nested_dicts(value)\n                and parent_id is not None\n                and parent_model is not None\n            ):\n                _extract_nested_list(value, parent_model, parent_id, extracted_tables)\n\n            else:\n                flat_record[key] = value\n\n        flat_data.append(flat_record)\n\n    return flat_data\n</code></pre>"},{"location":"reference/db/#t3api_utils.db.utils.export_duckdb_schema","title":"export_duckdb_schema","text":"<pre><code>export_duckdb_schema(*, con: DuckDBPyConnection) -&gt; str\n</code></pre> <p>Exports a human-readable representation of the DuckDB schema, including inferred foreign key-like relationships.</p> <p>Useful for creating AI-generated queries based on the schema.</p> <p>Parameters:</p> Name Type Description Default <code>con</code> <code>DuckDBPyConnection</code> <p>An active DuckDB connection.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the schema and inferred relationships.</p> Source code in <code>t3api_utils/db/utils.py</code> <pre><code>def export_duckdb_schema(*, con: duckdb.DuckDBPyConnection) -&gt; str:\n    \"\"\"\n    Exports a human-readable representation of the DuckDB schema,\n    including inferred foreign key-like relationships.\n\n    Useful for creating AI-generated queries based on the schema.\n\n    Args:\n        con: An active DuckDB connection.\n\n    Returns:\n        A string representation of the schema and inferred relationships.\n    \"\"\"\n    tables: List[Tuple[str]] = con.execute(\n        f\"\"\"\n        SELECT table_name\n        FROM duckdb_tables()\n        WHERE schema_name = '{SCHEMA_NAME}'\n        ORDER BY table_name\n        \"\"\"\n    ).fetchall()\n\n    schema_output: List[str] = []\n    seen_columns: Set[Tuple[str, str]] = set()\n\n    for (table_name,) in tables:\n        columns: List[Tuple[str, str]] = con.execute(\n            f\"\"\"\n            SELECT column_name, data_type\n            FROM duckdb_columns()\n            WHERE schema_name = '{SCHEMA_NAME}' AND table_name = '{table_name}'\n            ORDER BY column_name\n            \"\"\"\n        ).fetchall()\n\n        schema_output.append(f\"Table: {table_name}\")\n        for col_name, col_type in columns:\n            key = (table_name, col_name)\n            if key not in seen_columns:\n                seen_columns.add(key)\n                schema_output.append(f\"  - {col_name}: {col_type}\")\n        schema_output.append(\"\")\n\n    # Infer foreign-key-like relationships based on *_id column naming\n    fk_output: Set[str] = set()\n\n    for (table_name,) in tables:\n        col_names: List[Tuple[str]] = con.execute(\n            f\"\"\"\n            SELECT column_name\n            FROM duckdb_columns()\n            WHERE schema_name = '{SCHEMA_NAME}' AND table_name = '{table_name}'\n            \"\"\"\n        ).fetchall()\n\n        for (col_name,) in col_names:\n            if col_name.endswith(ID_SUFFIX):\n                ref_table = col_name[: -len(ID_SUFFIX)]\n                if any(t[0] == ref_table for t in tables):\n                    relation = f\"Inferred relation: {table_name}.{col_name} \u2192 {ref_table}.{ID_KEY}\"\n                    fk_output.add(relation)\n\n    if fk_output:\n        schema_output.append(\"Inferred Relationships:\")\n        schema_output.extend(f\"  - {line}\" for line in sorted(fk_output))\n\n    return \"\\n\".join(schema_output)\n</code></pre>"},{"location":"reference/db/#t3api_utils.db.utils.export_duckdb_constraints","title":"export_duckdb_constraints","text":"<pre><code>export_duckdb_constraints(*, con: DuckDBPyConnection) -&gt; List[Tuple[Any, ...]]\n</code></pre> <p>Retrieves all schema constraints (including primary and foreign keys).</p> <p>Parameters:</p> Name Type Description Default <code>con</code> <code>DuckDBPyConnection</code> <p>An active DuckDB connection.</p> required <p>Returns:</p> Type Description <code>List[Tuple[Any, ...]]</code> <p>A list of constraint tuples.</p> Source code in <code>t3api_utils/db/utils.py</code> <pre><code>def export_duckdb_constraints(\n    *, con: duckdb.DuckDBPyConnection\n) -&gt; List[Tuple[Any, ...]]:\n    \"\"\"\n    Retrieves all schema constraints (including primary and foreign keys).\n\n    Args:\n        con: An active DuckDB connection.\n\n    Returns:\n        A list of constraint tuples.\n    \"\"\"\n    return con.execute(\n        f\"\"\"\n        SELECT *\n        FROM duckdb_constraints()\n        ORDER BY table_name, constraint_type\n        \"\"\"\n    ).fetchall()\n</code></pre>"},{"location":"reference/db/#t3api_utils.db.utils.create_table_from_data","title":"create_table_from_data","text":"<pre><code>create_table_from_data(*, con: DuckDBPyConnection, data_dict: Union[Dict[Any, Dict[str, Any]], List[Dict[str, Any]]], name: str | None = None) -&gt; None\n</code></pre> <p>Creates a DuckDB table from the provided data using PyArrow. Automatically drops and recreates the table.</p> <p>Parameters:</p> Name Type Description Default <code>con</code> <code>DuckDBPyConnection</code> <p>An active DuckDB connection.</p> required <code>data_dict</code> <code>Union[Dict[Any, Dict[str, Any]], List[Dict[str, Any]]]</code> <p>The table data, either as a list or deduplicated dict of rows.</p> required <code>name</code> <code>str | None</code> <p>Optional name for the table. If not provided, will be inferred from data_model.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the table name cannot be inferred or data is empty.</p> Source code in <code>t3api_utils/db/utils.py</code> <pre><code>def create_table_from_data(\n    *,\n    con: duckdb.DuckDBPyConnection,\n    data_dict: Union[Dict[Any, Dict[str, Any]], List[Dict[str, Any]]],\n    name: str | None = None,\n) -&gt; None:\n    \"\"\"\n    Creates a DuckDB table from the provided data using PyArrow.\n    Automatically drops and recreates the table.\n\n    Args:\n        con: An active DuckDB connection.\n        data_dict: The table data, either as a list or deduplicated dict of rows.\n        name: Optional name for the table. If not provided, will be inferred from data_model.\n\n    Raises:\n        ValueError: If the table name cannot be inferred or data is empty.\n    \"\"\"\n    table_data: List[Dict[str, Any]] = (\n        list(data_dict.values()) if isinstance(data_dict, dict) else data_dict\n    )\n\n    if not table_data:\n        raise ValueError(\"No data to create table\")\n\n    if name is None:\n        if MODEL_KEY not in table_data[0]:\n            raise ValueError(f\"Missing {MODEL_KEY} key to infer table name\")\n        name = table_data[0][MODEL_KEY]\n\n    table = pa.Table.from_pylist(table_data)\n    # Drop both view and table to ensure clean slate (view first, then table)\n    con.execute(f'DROP VIEW IF EXISTS \"{name}\"')\n    con.execute(f'DROP TABLE IF EXISTS \"{name}\"')\n    con.register(name, table)\n    con.execute(f'CREATE TABLE \"{name}\" AS SELECT * FROM \"{name}\"')\n</code></pre>"},{"location":"reference/exceptions/","title":"Exceptions","text":""},{"location":"reference/exceptions/#t3api_utils.exceptions","title":"exceptions","text":"<p>Exception classes for the t3api_utils package.</p>"},{"location":"reference/exceptions/#t3api_utils.exceptions.AuthenticationError","title":"AuthenticationError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when authentication with the T3 API fails.</p>"},{"location":"reference/file/","title":"File I/O","text":""},{"location":"reference/file/#t3api_utils.file.utils","title":"utils","text":"<p>File I/O utilities for CSV/JSON serialization, path generation, and OS file opening.</p>"},{"location":"reference/file/#t3api_utils.file.utils.flatten_dict","title":"flatten_dict","text":"<pre><code>flatten_dict(*, d: Dict[str, Any], parent_key: str = '', sep: str = '.') -&gt; Dict[str, Any]\n</code></pre> <p>Recursively flattens a nested dictionary using dot notation.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>Dict[str, Any]</code> <p>The dictionary to flatten.</p> required <code>parent_key</code> <code>str</code> <p>Prefix for keys at the current nesting level (used during recursion).</p> <code>''</code> <code>sep</code> <code>str</code> <p>Separator between parent and child key segments.</p> <code>'.'</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A single-level dictionary with composite keys joined by <code>sep</code>.</p> Example <p>{\"a\": {\"b\": 1}} -&gt; {\"a.b\": 1}</p> Source code in <code>t3api_utils/file/utils.py</code> <pre><code>def flatten_dict(\n    *, d: Dict[str, Any], parent_key: str = \"\", sep: str = \".\"\n) -&gt; Dict[str, Any]:\n    \"\"\"Recursively flattens a nested dictionary using dot notation.\n\n    Args:\n        d: The dictionary to flatten.\n        parent_key: Prefix for keys at the current nesting level (used during\n            recursion).\n        sep: Separator between parent and child key segments.\n\n    Returns:\n        A single-level dictionary with composite keys joined by ``sep``.\n\n    Example:\n        {\"a\": {\"b\": 1}} -&gt; {\"a.b\": 1}\n    \"\"\"\n    result: Dict[str, Any] = {}\n    for k, v in d.items():\n        new_key = f\"{parent_key}{sep}{k}\" if parent_key else k\n        if isinstance(v, dict):\n            result.update(flatten_dict(d=v, parent_key=new_key, sep=sep))\n        else:\n            result[new_key] = v\n    return result\n</code></pre>"},{"location":"reference/file/#t3api_utils.file.utils.prioritized_fieldnames","title":"prioritized_fieldnames","text":"<pre><code>prioritized_fieldnames(*, dicts: List[Dict[str, Any]]) -&gt; List[str]\n</code></pre> <p>Orders CSV fieldnames by priority list, then appends remaining keys alphabetically.</p> <p>Parameters:</p> Name Type Description Default <code>dicts</code> <code>List[Dict[str, Any]]</code> <p>List of dictionaries whose keys represent fieldnames.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>An ordered list of fieldnames with priority fields first, followed by</p> <code>List[str]</code> <p>any remaining keys in alphabetical order.</p> Source code in <code>t3api_utils/file/utils.py</code> <pre><code>def prioritized_fieldnames(*, dicts: List[Dict[str, Any]]) -&gt; List[str]:\n    \"\"\"Orders CSV fieldnames by priority list, then appends remaining keys alphabetically.\n\n    Args:\n        dicts: List of dictionaries whose keys represent fieldnames.\n\n    Returns:\n        An ordered list of fieldnames with priority fields first, followed by\n        any remaining keys in alphabetical order.\n    \"\"\"\n    all_keys = {key for row in dicts for key in row.keys()}\n    prioritized = [key for key in PRIORITY_FIELDS if key in all_keys]\n    remaining = sorted(all_keys - set(prioritized))\n    return prioritized + remaining\n</code></pre>"},{"location":"reference/file/#t3api_utils.file.utils.default_json_serializer","title":"default_json_serializer","text":"<pre><code>default_json_serializer(*, obj: object) -&gt; str\n</code></pre> <p>Fallback serializer for non-JSON-native types.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>The object that <code>json.dump</code> could not serialize natively.</p> required <p>Returns:</p> Type Description <code>str</code> <p>An ISO-format string if <code>obj</code> is a <code>datetime</code> instance.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the object type is not supported for serialization.</p> Source code in <code>t3api_utils/file/utils.py</code> <pre><code>def default_json_serializer(*, obj: object) -&gt; str:\n    \"\"\"Fallback serializer for non-JSON-native types.\n\n    Args:\n        obj: The object that ``json.dump`` could not serialize natively.\n\n    Returns:\n        An ISO-format string if ``obj`` is a ``datetime`` instance.\n\n    Raises:\n        TypeError: If the object type is not supported for serialization.\n    \"\"\"\n    if isinstance(obj, datetime):\n        return obj.isoformat()\n    raise TypeError(f\"Object of type {type(obj).__name__} is not JSON serializable\")\n</code></pre>"},{"location":"reference/file/#t3api_utils.file.utils.generate_output_path","title":"generate_output_path","text":"<pre><code>generate_output_path(*, model_name: str, license_number: str, output_dir: str, extension: str) -&gt; Path\n</code></pre> <p>Constructs the output file path with consistent naming.</p> <p>The filename format is <code>&lt;model_name&gt;__&lt;license_number&gt;__&lt;timestamp&gt;.&lt;ext&gt;</code>. Parent directories are created automatically if they do not exist.</p> <p>Parameters:</p> Name Type Description Default <code>model_name</code> <code>str</code> <p>Logical model name included in the filename.</p> required <code>license_number</code> <code>str</code> <p>License identifier included in the filename.</p> required <code>output_dir</code> <code>str</code> <p>Directory where the file will be saved.</p> required <code>extension</code> <code>str</code> <p>File extension without the leading dot (e.g., <code>\"csv\"</code>).</p> required <p>Returns:</p> Type Description <code>Path</code> <p>A <code>Path</code> to the generated output file.</p> Source code in <code>t3api_utils/file/utils.py</code> <pre><code>def generate_output_path(\n    *, model_name: str, license_number: str, output_dir: str, extension: str\n) -&gt; Path:\n    \"\"\"Constructs the output file path with consistent naming.\n\n    The filename format is ``&lt;model_name&gt;__&lt;license_number&gt;__&lt;timestamp&gt;.&lt;ext&gt;``.\n    Parent directories are created automatically if they do not exist.\n\n    Args:\n        model_name: Logical model name included in the filename.\n        license_number: License identifier included in the filename.\n        output_dir: Directory where the file will be saved.\n        extension: File extension without the leading dot (e.g., ``\"csv\"``).\n\n    Returns:\n        A ``Path`` to the generated output file.\n    \"\"\"\n    timestamp = datetime.now().isoformat(timespec=\"seconds\").replace(\":\", \"-\")\n    filename = f\"{model_name}__{license_number}__{timestamp}.{extension}\"\n    filepath = Path(output_dir) / filename\n    filepath.parent.mkdir(parents=True, exist_ok=True)\n    return filepath\n</code></pre>"},{"location":"reference/file/#t3api_utils.file.utils.save_dicts_to_json","title":"save_dicts_to_json","text":"<pre><code>save_dicts_to_json(*, dicts: List[Dict[str, Any]], model_name: str, license_number: str, output_dir: str = 'output') -&gt; Path\n</code></pre> <p>Saves a list of dictionaries to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>dicts</code> <code>List[Dict[str, Any]]</code> <p>Non-empty list of dictionaries to serialize.</p> required <code>model_name</code> <code>str</code> <p>Logical model name used in the output filename.</p> required <code>license_number</code> <code>str</code> <p>License identifier used in the output filename.</p> required <code>output_dir</code> <code>str</code> <p>Directory where the JSON file will be saved.</p> <code>'output'</code> <p>Returns:</p> Type Description <code>Path</code> <p>The <code>Path</code> to the written JSON file.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>dicts</code> is empty.</p> Source code in <code>t3api_utils/file/utils.py</code> <pre><code>def save_dicts_to_json(\n    *,\n    dicts: List[Dict[str, Any]],\n    model_name: str,\n    license_number: str,\n    output_dir: str = \"output\",\n) -&gt; Path:\n    \"\"\"Saves a list of dictionaries to a JSON file.\n\n    Args:\n        dicts: Non-empty list of dictionaries to serialize.\n        model_name: Logical model name used in the output filename.\n        license_number: License identifier used in the output filename.\n        output_dir: Directory where the JSON file will be saved.\n\n    Returns:\n        The ``Path`` to the written JSON file.\n\n    Raises:\n        ValueError: If ``dicts`` is empty.\n    \"\"\"\n    if not dicts:\n        raise ValueError(\"Input list is empty\")\n\n    filepath = generate_output_path(model_name=model_name, license_number=license_number, output_dir=output_dir, extension=\"json\")\n\n    with open(filepath, \"w\", encoding=\"utf-8\") as f:\n        json.dump(\n            dicts, f, ensure_ascii=False, indent=2, default=lambda obj: default_json_serializer(obj=obj)\n        )\n\n    logger.info(f\"Wrote {len(dicts)} {model_name} objects to {filepath}\")\n    return filepath\n</code></pre>"},{"location":"reference/file/#t3api_utils.file.utils.save_dicts_to_csv","title":"save_dicts_to_csv","text":"<pre><code>save_dicts_to_csv(*, dicts: List[Dict[str, Any]], model_name: str, license_number: str, output_dir: str = 'output', strip_empty_columns: bool = False) -&gt; Path\n</code></pre> <p>Saves a list of (possibly nested) dictionaries to a CSV file after flattening.</p> <p>Parameters:</p> Name Type Description Default <code>dicts</code> <code>List[Dict[str, Any]]</code> <p>Non-empty list of input dictionaries (may contain nested dicts).</p> required <code>model_name</code> <code>str</code> <p>Logical model name used in the output filename.</p> required <code>license_number</code> <code>str</code> <p>License identifier used in the output filename.</p> required <code>output_dir</code> <code>str</code> <p>Directory where the CSV file will be saved.</p> <code>'output'</code> <code>strip_empty_columns</code> <code>bool</code> <p>If True, columns where every value is <code>None</code>, <code>\"\"</code>, or <code>[]</code> will be removed.</p> <code>False</code> <p>Returns:</p> Type Description <code>Path</code> <p>The <code>Path</code> to the written CSV file.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>dicts</code> is empty.</p> Source code in <code>t3api_utils/file/utils.py</code> <pre><code>def save_dicts_to_csv(\n    *,\n    dicts: List[Dict[str, Any]],\n    model_name: str,\n    license_number: str,\n    output_dir: str = \"output\",\n    strip_empty_columns: bool = False,\n) -&gt; Path:\n    \"\"\"Saves a list of (possibly nested) dictionaries to a CSV file after flattening.\n\n    Args:\n        dicts: Non-empty list of input dictionaries (may contain nested dicts).\n        model_name: Logical model name used in the output filename.\n        license_number: License identifier used in the output filename.\n        output_dir: Directory where the CSV file will be saved.\n        strip_empty_columns: If True, columns where every value is ``None``,\n            ``\"\"``, or ``[]`` will be removed.\n\n    Returns:\n        The ``Path`` to the written CSV file.\n\n    Raises:\n        ValueError: If ``dicts`` is empty.\n    \"\"\"\n    if not dicts:\n        raise ValueError(\"Input list is empty\")\n\n    flat_dicts = [flatten_dict(d=d) for d in dicts]\n\n    if strip_empty_columns:\n        # Determine which fields are completely empty\n        all_keys = {key for d in flat_dicts for key in d}\n        non_empty_keys = {\n            key\n            for key in all_keys\n            if any(d.get(key) not in (None, \"\", []) for d in flat_dicts)\n        }\n        flat_dicts = [\n            {k: v for k, v in d.items() if k in non_empty_keys} for d in flat_dicts\n        ]\n\n    fieldnames = prioritized_fieldnames(dicts=flat_dicts)\n    filepath = generate_output_path(model_name=model_name, license_number=license_number, output_dir=output_dir, extension=\"csv\")\n\n    with open(filepath, mode=\"w\", encoding=\"utf-8\", newline=\"\") as f:\n        writer = csv.DictWriter(f, fieldnames=fieldnames)\n        writer.writeheader()\n        writer.writerows(flat_dicts)\n\n    logger.info(f\"Wrote {len(flat_dicts)} {model_name} objects to {filepath}\")\n    return filepath\n</code></pre>"},{"location":"reference/file/#t3api_utils.file.utils.open_file","title":"open_file","text":"<pre><code>open_file(*, path: Path) -&gt; None\n</code></pre> <p>Opens a file using the default application for the current OS.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Filesystem path to the file to open.</p> required Source code in <code>t3api_utils/file/utils.py</code> <pre><code>def open_file(*, path: Path) -&gt; None:\n    \"\"\"Opens a file using the default application for the current OS.\n\n    Args:\n        path: Filesystem path to the file to open.\n    \"\"\"\n    try:\n        if sys.platform == \"darwin\":\n            subprocess.run([\"open\", str(path)], check=False)\n        elif os.name == \"nt\":\n            os.startfile(path)\n        elif os.name == \"posix\":\n            subprocess.run([\"xdg-open\", str(path)], check=False)\n    except Exception as e:\n        logger.error(f\"Failed to open file: {e}\")\n</code></pre>"},{"location":"reference/http/","title":"HTTP","text":""},{"location":"reference/http/#t3api_utils.http.utils","title":"utils","text":"<p>Reusable HTTP utilities for t3api-utils (sync + async).</p>"},{"location":"reference/http/#t3api_utils.http.utils--scope-by-design","title":"Scope (by design)","text":"<p>Configures and performs network activity (clients, retries, JSON handling,  headers, SSL, proxies)</p>"},{"location":"reference/http/#t3api_utils.http.utils--highlights","title":"Highlights","text":"<ul> <li>Centralized <code>httpx</code> client builders (sync + async) with sane defaults   (timeout, HTTP/2, SSL via <code>certifi</code>, base headers, optional proxies).</li> <li>Lightweight retry policy with exponential backoff + jitter.</li> <li>Standard JSON request helpers with consistent error text.</li> <li>Simple helpers to attach/remove Bearer tokens without performing auth.</li> <li>Optional request/response logging hooks.</li> </ul>"},{"location":"reference/http/#t3api_utils.http.utils--examples","title":"Examples","text":"<p>Sync client with bearer token:     from t3api_utils.http import build_client, set_bearer_token, request_json</p> <pre><code>client = build_client()\nset_bearer_token(client=client, token=\"&lt;token&gt;\")\ndata = request_json(client=client, method=\"GET\", url=\"/v2/auth/whoami\")\n</code></pre> Async with logging hooks <p>from t3api_utils.http import build_async_client, arequest_json, LoggingHooks</p> <p>hooks = LoggingHooks(enabled=True) async with build_async_client(hooks=hooks) as aclient:     data = await arequest_json(aclient=aclient, method=\"GET\", url=\"/healthz\")</p>"},{"location":"reference/http/#t3api_utils.http.utils.HTTPConfig","title":"HTTPConfig  <code>dataclass</code>","text":"<pre><code>HTTPConfig(host: str = _get_default_host(), timeout: float = DEFAULT_TIMEOUT, verify_ssl: Union[bool, str] = certifi.where(), base_headers: Mapping[str, str] = (lambda: {'User-Agent': DEFAULT_USER_AGENT})(), proxies: Optional[Union[str, Mapping[str, str]]] = None)\n</code></pre> <p>Base HTTP client configuration (no routes).</p> <p>Attributes:</p> Name Type Description <code>host</code> <code>str</code> <p>Base URL of the API server (e.g. <code>\"https://api.example.com\"</code>). Defaults to the value returned by the config manager.</p> <code>timeout</code> <code>float</code> <p>Request timeout in seconds. Defaults to <code>DEFAULT_TIMEOUT</code>.</p> <code>verify_ssl</code> <code>Union[bool, str]</code> <p>SSL verification setting. Pass <code>True</code> to use default CA bundle, <code>False</code> to disable verification, or a file path to a custom CA certificate. Defaults to the <code>certifi</code> CA bundle.</p> <code>base_headers</code> <code>Mapping[str, str]</code> <p>Default headers attached to every request built by this configuration. Defaults to a <code>User-Agent</code> header.</p> <code>proxies</code> <code>Optional[Union[str, Mapping[str, str]]]</code> <p>Optional proxy URL string or mapping of scheme to proxy URL (e.g. <code>{\"https://\": \"http://proxy:8080\"}</code>).</p>"},{"location":"reference/http/#t3api_utils.http.utils.HTTPConfig.ssl_context","title":"ssl_context  <code>property</code>","text":"<pre><code>ssl_context: Union[bool, SSLContext]\n</code></pre> <p>Get proper SSL context for httpx.</p>"},{"location":"reference/http/#t3api_utils.http.utils.RetryPolicy","title":"RetryPolicy  <code>dataclass</code>","text":"<pre><code>RetryPolicy(max_attempts: int = 3, backoff_factor: float = 0.5, retry_methods: Sequence[str] = ('GET', 'HEAD', 'OPTIONS', 'DELETE', 'PUT', 'PATCH', 'POST'), retry_statuses: Sequence[int] = (408, 409, 425, 429, 500, 502, 503, 504))\n</code></pre> <p>Retry policy for transient failures. Route-agnostic.</p> <p>Note: writes (POST/PUT/PATCH/DELETE) are included by default. If your call is not idempotent, provide a custom policy at the callsite.</p> <p>Attributes:</p> Name Type Description <code>max_attempts</code> <code>int</code> <p>Maximum number of attempts (including the initial request). Defaults to <code>3</code>.</p> <code>backoff_factor</code> <code>float</code> <p>Base delay in seconds for exponential backoff. Actual sleep is <code>backoff_factor * 2^(attempt - 2)</code> with +/- 20 % jitter. Defaults to <code>0.5</code>.</p> <code>retry_methods</code> <code>Sequence[str]</code> <p>HTTP methods eligible for automatic retry. Defaults to all standard methods.</p> <code>retry_statuses</code> <code>Sequence[int]</code> <p>HTTP status codes that trigger a retry. Defaults to common transient-error codes (408, 409, 425, 429, 500, 502, 503, 504).</p>"},{"location":"reference/http/#t3api_utils.http.utils.LoggingHooks","title":"LoggingHooks  <code>dataclass</code>","text":"<pre><code>LoggingHooks(enabled: bool = False)\n</code></pre> <p>Optional request/response logging via httpx event hooks.</p> <p>Attributes:</p> Name Type Description <code>enabled</code> <code>bool</code> <p>When <code>True</code>, debug-level log messages are emitted for every outgoing request and incoming response. Defaults to <code>False</code>.</p>"},{"location":"reference/http/#t3api_utils.http.utils.LoggingHooks.as_hooks","title":"as_hooks","text":"<pre><code>as_hooks(*, async_client: bool = False) -&gt; Optional[Dict[str, Any]]\n</code></pre> <p>Build an httpx <code>event_hooks</code> mapping for request/response logging.</p> <p>Parameters:</p> Name Type Description Default <code>async_client</code> <code>bool</code> <p>When <code>True</code>, returns async hook callables suitable for <code>httpx.AsyncClient</code>. When <code>False</code> (default), returns synchronous callables for <code>httpx.Client</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>A dict with <code>\"request\"</code> and <code>\"response\"</code> hook lists, or</p> <code>Optional[Dict[str, Any]]</code> <p><code>None</code> if logging is disabled.</p> Source code in <code>t3api_utils/http/utils.py</code> <pre><code>def as_hooks(self, *, async_client: bool = False) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"Build an httpx ``event_hooks`` mapping for request/response logging.\n\n    Args:\n        async_client: When ``True``, returns async hook callables\n            suitable for ``httpx.AsyncClient``. When ``False``\n            (default), returns synchronous callables for\n            ``httpx.Client``.\n\n    Returns:\n        A dict with ``\"request\"`` and ``\"response\"`` hook lists, or\n        ``None`` if logging is disabled.\n    \"\"\"\n    if not self.enabled:\n        return None\n\n    async def _alog_request(request: httpx.Request) -&gt; None:\n        log.debug(\"HTTP %s %s\", request.method, request.url)\n\n    async def _alog_response(response: httpx.Response) -&gt; None:\n        req = response.request\n        log.debug(\"HTTP %s %s -&gt; %s\", req.method, req.url, response.status_code)\n\n    def _log_request(request: httpx.Request) -&gt; None:\n        log.debug(\"HTTP %s %s\", request.method, request.url)\n\n    def _log_response(response: httpx.Response) -&gt; None:\n        req = response.request\n        log.debug(\"HTTP %s %s -&gt; %s\", req.method, req.url, response.status_code)\n\n    if async_client:\n        return {\n            \"request\": [_alog_request],\n            \"response\": [_alog_response],\n        }\n    else:\n        return {\n            \"request\": [_log_request],\n            \"response\": [_log_response],\n        }\n</code></pre>"},{"location":"reference/http/#t3api_utils.http.utils.T3HTTPError","title":"T3HTTPError","text":"<pre><code>T3HTTPError(message: str, *, response: Optional[Response] = None)\n</code></pre> <p>               Bases: <code>HTTPError</code></p> <p>Raised when a request fails permanently or response parsing fails.</p> <p>Initialize a T3HTTPError.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Human-readable description of the failure.</p> required <code>response</code> <code>Optional[Response]</code> <p>The <code>httpx.Response</code> that caused the error, if available. Retained for callers that need to inspect status codes or response bodies.</p> <code>None</code> Source code in <code>t3api_utils/http/utils.py</code> <pre><code>def __init__(\n    self, message: str, *, response: Optional[httpx.Response] = None\n) -&gt; None:\n    \"\"\"Initialize a T3HTTPError.\n\n    Args:\n        message: Human-readable description of the failure.\n        response: The ``httpx.Response`` that caused the error, if\n            available. Retained for callers that need to inspect\n            status codes or response bodies.\n    \"\"\"\n    super().__init__(message)\n    self.response = response\n</code></pre>"},{"location":"reference/http/#t3api_utils.http.utils.T3HTTPError.status_code","title":"status_code  <code>property</code>","text":"<pre><code>status_code: Optional[int]\n</code></pre> <p>HTTP status code from the stored response, or <code>None</code> if unavailable.</p>"},{"location":"reference/http/#t3api_utils.http.utils.build_client","title":"build_client","text":"<pre><code>build_client(*, config: Optional[HTTPConfig] = None, headers: Optional[Mapping[str, str]] = None, hooks: Optional[LoggingHooks] = None) -&gt; httpx.Client\n</code></pre> <p>Construct a configured <code>httpx.Client</code> with sane defaults.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Optional[HTTPConfig]</code> <p>HTTP configuration (host, timeout, SSL, proxies). Defaults to <code>HTTPConfig()</code> when <code>None</code>.</p> <code>None</code> <code>headers</code> <code>Optional[Mapping[str, str]]</code> <p>Extra headers merged on top of <code>config.base_headers</code>.</p> <code>None</code> <code>hooks</code> <code>Optional[LoggingHooks]</code> <p>Optional logging hooks attached as httpx event hooks.</p> <code>None</code> <p>Returns:</p> Type Description <code>Client</code> <p>A ready-to-use <code>httpx.Client</code> instance.</p> Source code in <code>t3api_utils/http/utils.py</code> <pre><code>def build_client(\n    *,\n    config: Optional[HTTPConfig] = None,\n    headers: Optional[Mapping[str, str]] = None,\n    hooks: Optional[LoggingHooks] = None,\n) -&gt; httpx.Client:\n    \"\"\"Construct a configured ``httpx.Client`` with sane defaults.\n\n    Args:\n        config: HTTP configuration (host, timeout, SSL, proxies).\n            Defaults to ``HTTPConfig()`` when ``None``.\n        headers: Extra headers merged on top of ``config.base_headers``.\n        hooks: Optional logging hooks attached as httpx event hooks.\n\n    Returns:\n        A ready-to-use ``httpx.Client`` instance.\n    \"\"\"\n    cfg = config or HTTPConfig()\n    merged_headers = _merge_headers(cfg.base_headers, headers)\n\n    return httpx.Client(\n        base_url=cfg.host.rstrip(\"/\"),\n        timeout=cfg.timeout,\n        verify=cfg.ssl_context,\n        headers=merged_headers,\n        proxy=cfg.proxies,  # type: ignore[arg-type]\n        http2=False,\n        event_hooks=(hooks.as_hooks(async_client=False) if hooks else None),\n    )\n</code></pre>"},{"location":"reference/http/#t3api_utils.http.utils.build_async_client","title":"build_async_client","text":"<pre><code>build_async_client(*, config: Optional[HTTPConfig] = None, headers: Optional[Mapping[str, str]] = None, hooks: Optional[LoggingHooks] = None) -&gt; httpx.AsyncClient\n</code></pre> <p>Construct a configured <code>httpx.AsyncClient</code> with sane defaults.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Optional[HTTPConfig]</code> <p>HTTP configuration (host, timeout, SSL, proxies). Defaults to <code>HTTPConfig()</code> when <code>None</code>.</p> <code>None</code> <code>headers</code> <code>Optional[Mapping[str, str]]</code> <p>Extra headers merged on top of <code>config.base_headers</code>.</p> <code>None</code> <code>hooks</code> <code>Optional[LoggingHooks]</code> <p>Optional logging hooks attached as httpx event hooks.</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncClient</code> <p>A ready-to-use <code>httpx.AsyncClient</code> instance. Should be used as</p> <code>AsyncClient</code> <p>an async context manager or closed explicitly when finished.</p> Source code in <code>t3api_utils/http/utils.py</code> <pre><code>def build_async_client(\n    *,\n    config: Optional[HTTPConfig] = None,\n    headers: Optional[Mapping[str, str]] = None,\n    hooks: Optional[LoggingHooks] = None,\n) -&gt; httpx.AsyncClient:\n    \"\"\"Construct a configured ``httpx.AsyncClient`` with sane defaults.\n\n    Args:\n        config: HTTP configuration (host, timeout, SSL, proxies).\n            Defaults to ``HTTPConfig()`` when ``None``.\n        headers: Extra headers merged on top of ``config.base_headers``.\n        hooks: Optional logging hooks attached as httpx event hooks.\n\n    Returns:\n        A ready-to-use ``httpx.AsyncClient`` instance. Should be used as\n        an async context manager or closed explicitly when finished.\n    \"\"\"\n    cfg = config or HTTPConfig()\n    merged_headers = _merge_headers(cfg.base_headers, headers)\n\n    return httpx.AsyncClient(\n        base_url=cfg.host.rstrip(\"/\"),\n        timeout=cfg.timeout,\n        verify=cfg.ssl_context,\n        headers=merged_headers,\n        proxy=cfg.proxies,  # type: ignore[arg-type]\n        http2=False,\n        event_hooks=(hooks.as_hooks(async_client=True) if hooks else None),\n    )\n</code></pre>"},{"location":"reference/http/#t3api_utils.http.utils.request_json","title":"request_json","text":"<pre><code>request_json(*, client: Client, method: str, url: str, params: Optional[Mapping[str, Any]] = None, json_body: Optional[Any] = None, headers: Optional[Mapping[str, str]] = None, policy: Optional[RetryPolicy] = None, expected_status: Union[int, Iterable[int]] = (200, 201, 202, 204), timeout: Optional[Union[float, Timeout]] = None, request_id: Optional[str] = None) -&gt; Any\n</code></pre> <p>Issue a synchronous JSON request with automatic retries.</p> <p>Sends the request via the provided <code>httpx.Client</code>, retrying on transient failures according to the supplied (or default) retry policy. The response body is parsed as JSON and returned.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>An <code>httpx.Client</code> (typically from :func:<code>build_client</code>).</p> required <code>method</code> <code>str</code> <p>HTTP method (e.g. <code>\"GET\"</code>, <code>\"POST\"</code>).</p> required <code>url</code> <code>str</code> <p>Request URL or path (resolved against the client's base URL).</p> required <code>params</code> <code>Optional[Mapping[str, Any]]</code> <p>Optional query-string parameters.</p> <code>None</code> <code>json_body</code> <code>Optional[Any]</code> <p>Optional JSON-serializable request body.</p> <code>None</code> <code>headers</code> <code>Optional[Mapping[str, str]]</code> <p>Optional per-request headers merged on top of the client's default headers.</p> <code>None</code> <code>policy</code> <code>Optional[RetryPolicy]</code> <p>Retry policy. Defaults to <code>RetryPolicy()</code> when <code>None</code>.</p> <code>None</code> <code>expected_status</code> <code>Union[int, Iterable[int]]</code> <p>Status code(s) considered successful. Defaults to <code>(200, 201, 202, 204)</code>.</p> <code>(200, 201, 202, 204)</code> <code>timeout</code> <code>Optional[Union[float, Timeout]]</code> <p>Per-request timeout override. <code>None</code> uses the client default.</p> <code>None</code> <code>request_id</code> <code>Optional[str]</code> <p>Optional value set as the <code>X-Request-ID</code> header (unless already present in headers).</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>Parsed JSON response body, or <code>None</code> for 204 / empty responses.</p> <p>Raises:</p> Type Description <code>T3HTTPError</code> <p>If the response status is not in expected_status after all retries are exhausted, or if the response body cannot be decoded as JSON.</p> Source code in <code>t3api_utils/http/utils.py</code> <pre><code>def request_json(\n    *,\n    client: httpx.Client,\n    method: str,\n    url: str,\n    params: Optional[Mapping[str, Any]] = None,\n    json_body: Optional[Any] = None,\n    headers: Optional[Mapping[str, str]] = None,\n    policy: Optional[RetryPolicy] = None,\n    expected_status: Union[int, Iterable[int]] = (200, 201, 202, 204),\n    timeout: Optional[Union[float, httpx.Timeout]] = None,\n    request_id: Optional[str] = None,\n) -&gt; Any:\n    \"\"\"Issue a synchronous JSON request with automatic retries.\n\n    Sends the request via the provided ``httpx.Client``, retrying on\n    transient failures according to the supplied (or default) retry\n    policy. The response body is parsed as JSON and returned.\n\n    Args:\n        client: An ``httpx.Client`` (typically from :func:`build_client`).\n        method: HTTP method (e.g. ``\"GET\"``, ``\"POST\"``).\n        url: Request URL or path (resolved against the client's base URL).\n        params: Optional query-string parameters.\n        json_body: Optional JSON-serializable request body.\n        headers: Optional per-request headers merged on top of the\n            client's default headers.\n        policy: Retry policy. Defaults to ``RetryPolicy()`` when ``None``.\n        expected_status: Status code(s) considered successful. Defaults\n            to ``(200, 201, 202, 204)``.\n        timeout: Per-request timeout override. ``None`` uses the client\n            default.\n        request_id: Optional value set as the ``X-Request-ID`` header\n            (unless already present in *headers*).\n\n    Returns:\n        Parsed JSON response body, or ``None`` for 204 / empty responses.\n\n    Raises:\n        T3HTTPError: If the response status is not in *expected_status*\n            after all retries are exhausted, or if the response body\n            cannot be decoded as JSON.\n    \"\"\"\n    pol = policy or RetryPolicy()\n    exp: Tuple[int, ...] = (\n        (expected_status,) if isinstance(expected_status, int) else tuple(expected_status)\n    )\n\n    # Merge headers + optional request id\n    merged_headers = dict(headers or {})\n    if request_id and \"X-Request-ID\" not in merged_headers:\n        merged_headers[\"X-Request-ID\"] = request_id\n\n    attempt = 0\n    while True:\n        attempt += 1\n        try:\n            resp = client.request(\n                method.upper(),\n                url,\n                params=params,\n                json=json_body,\n                headers=merged_headers or None,\n                timeout=timeout,\n            )\n            if resp.status_code not in exp:\n                if _should_retry(policy=pol, attempt=attempt, method=method, exc=None, resp=resp):\n                    _sleep_with_backoff(pol, attempt)\n                    continue\n                raise T3HTTPError(_format_http_error_message(resp), response=resp)\n\n            if resp.status_code == 204:\n                return None\n            if not resp.content:\n                return None\n            try:\n                return resp.json()\n            except json.JSONDecodeError as e:\n                raise T3HTTPError(\"Failed to decode JSON response.\", response=resp) from e\n        except httpx.HTTPError as e:\n            if _should_retry(policy=pol, attempt=attempt, method=method, exc=e, resp=None):\n                _sleep_with_backoff(pol, attempt)\n                continue\n            raise T3HTTPError(str(e)) from e\n</code></pre>"},{"location":"reference/http/#t3api_utils.http.utils.arequest_json","title":"arequest_json  <code>async</code>","text":"<pre><code>arequest_json(*, aclient: AsyncClient, method: str, url: str, params: Optional[Mapping[str, Any]] = None, json_body: Optional[Any] = None, headers: Optional[Mapping[str, str]] = None, policy: Optional[RetryPolicy] = None, expected_status: Union[int, Iterable[int]] = (200, 201, 202, 204), timeout: Optional[Union[float, Timeout]] = None, request_id: Optional[str] = None) -&gt; Any\n</code></pre> <p>Issue an asynchronous JSON request with automatic retries.</p> <p>Async equivalent of :func:<code>request_json</code>. Sends the request via the provided <code>httpx.AsyncClient</code>, retrying on transient failures according to the supplied (or default) retry policy.</p> <p>Parameters:</p> Name Type Description Default <code>aclient</code> <code>AsyncClient</code> <p>An <code>httpx.AsyncClient</code> (typically from :func:<code>build_async_client</code>).</p> required <code>method</code> <code>str</code> <p>HTTP method (e.g. <code>\"GET\"</code>, <code>\"POST\"</code>).</p> required <code>url</code> <code>str</code> <p>Request URL or path (resolved against the client's base URL).</p> required <code>params</code> <code>Optional[Mapping[str, Any]]</code> <p>Optional query-string parameters.</p> <code>None</code> <code>json_body</code> <code>Optional[Any]</code> <p>Optional JSON-serializable request body.</p> <code>None</code> <code>headers</code> <code>Optional[Mapping[str, str]]</code> <p>Optional per-request headers merged on top of the client's default headers.</p> <code>None</code> <code>policy</code> <code>Optional[RetryPolicy]</code> <p>Retry policy. Defaults to <code>RetryPolicy()</code> when <code>None</code>.</p> <code>None</code> <code>expected_status</code> <code>Union[int, Iterable[int]]</code> <p>Status code(s) considered successful. Defaults to <code>(200, 201, 202, 204)</code>.</p> <code>(200, 201, 202, 204)</code> <code>timeout</code> <code>Optional[Union[float, Timeout]]</code> <p>Per-request timeout override. <code>None</code> uses the client default.</p> <code>None</code> <code>request_id</code> <code>Optional[str]</code> <p>Optional value set as the <code>X-Request-ID</code> header (unless already present in headers).</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>Parsed JSON response body, or <code>None</code> for 204 / empty responses.</p> <p>Raises:</p> Type Description <code>T3HTTPError</code> <p>If the response status is not in expected_status after all retries are exhausted, or if the response body cannot be decoded as JSON.</p> Source code in <code>t3api_utils/http/utils.py</code> <pre><code>async def arequest_json(\n    *,\n    aclient: httpx.AsyncClient,\n    method: str,\n    url: str,\n    params: Optional[Mapping[str, Any]] = None,\n    json_body: Optional[Any] = None,\n    headers: Optional[Mapping[str, str]] = None,\n    policy: Optional[RetryPolicy] = None,\n    expected_status: Union[int, Iterable[int]] = (200, 201, 202, 204),\n    timeout: Optional[Union[float, httpx.Timeout]] = None,\n    request_id: Optional[str] = None,\n) -&gt; Any:\n    \"\"\"Issue an asynchronous JSON request with automatic retries.\n\n    Async equivalent of :func:`request_json`. Sends the request via the\n    provided ``httpx.AsyncClient``, retrying on transient failures\n    according to the supplied (or default) retry policy.\n\n    Args:\n        aclient: An ``httpx.AsyncClient`` (typically from\n            :func:`build_async_client`).\n        method: HTTP method (e.g. ``\"GET\"``, ``\"POST\"``).\n        url: Request URL or path (resolved against the client's base URL).\n        params: Optional query-string parameters.\n        json_body: Optional JSON-serializable request body.\n        headers: Optional per-request headers merged on top of the\n            client's default headers.\n        policy: Retry policy. Defaults to ``RetryPolicy()`` when ``None``.\n        expected_status: Status code(s) considered successful. Defaults\n            to ``(200, 201, 202, 204)``.\n        timeout: Per-request timeout override. ``None`` uses the client\n            default.\n        request_id: Optional value set as the ``X-Request-ID`` header\n            (unless already present in *headers*).\n\n    Returns:\n        Parsed JSON response body, or ``None`` for 204 / empty responses.\n\n    Raises:\n        T3HTTPError: If the response status is not in *expected_status*\n            after all retries are exhausted, or if the response body\n            cannot be decoded as JSON.\n    \"\"\"\n    pol = policy or RetryPolicy()\n    exp: Tuple[int, ...] = (\n        (expected_status,) if isinstance(expected_status, int) else tuple(expected_status)\n    )\n\n    # Merge headers + optional request id\n    merged_headers = dict(headers or {})\n    if request_id and \"X-Request-ID\" not in merged_headers:\n        merged_headers[\"X-Request-ID\"] = request_id\n\n    attempt = 0\n    while True:\n        attempt += 1\n        try:\n            resp = await aclient.request(\n                method.upper(),\n                url,\n                params=params,\n                json=json_body,\n                headers=merged_headers or None,\n                timeout=timeout,\n            )\n            if resp.status_code not in exp:\n                if _should_retry(policy=pol, attempt=attempt, method=method, exc=None, resp=resp):\n                    await _async_sleep_with_backoff(pol, attempt)\n                    continue\n                raise T3HTTPError(_format_http_error_message(resp), response=resp)\n\n            if resp.status_code == 204:\n                return None\n            if not resp.content:\n                return None\n            try:\n                return resp.json()\n            except json.JSONDecodeError as e:\n                raise T3HTTPError(\"Failed to decode JSON response.\", response=resp) from e\n        except httpx.HTTPError as e:\n            if _should_retry(policy=pol, attempt=attempt, method=method, exc=e, resp=None):\n                await _async_sleep_with_backoff(pol, attempt)\n                continue\n            raise T3HTTPError(str(e)) from e\n</code></pre>"},{"location":"reference/http/#t3api_utils.http.utils.set_bearer_token","title":"set_bearer_token","text":"<pre><code>set_bearer_token(*, client: Union[Client, AsyncClient], token: str) -&gt; None\n</code></pre> <p>Attach or replace the <code>Authorization: Bearer</code> header on a client.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Union[Client, AsyncClient]</code> <p>Sync or async <code>httpx</code> client whose headers will be modified in place.</p> required <code>token</code> <code>str</code> <p>Raw bearer token string (without the <code>Bearer</code> prefix).</p> required Source code in <code>t3api_utils/http/utils.py</code> <pre><code>def set_bearer_token(*, client: Union[httpx.Client, httpx.AsyncClient], token: str) -&gt; None:\n    \"\"\"Attach or replace the ``Authorization: Bearer`` header on a client.\n\n    Args:\n        client: Sync or async ``httpx`` client whose headers will be\n            modified in place.\n        token: Raw bearer token string (without the ``Bearer `` prefix).\n    \"\"\"\n    client.headers[\"Authorization\"] = f\"Bearer {token}\"\n</code></pre>"},{"location":"reference/http/#t3api_utils.http.utils.clear_bearer_token","title":"clear_bearer_token","text":"<pre><code>clear_bearer_token(*, client: Union[Client, AsyncClient]) -&gt; None\n</code></pre> <p>Remove the <code>Authorization</code> header from a client, if present.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Union[Client, AsyncClient]</code> <p>Sync or async <code>httpx</code> client whose headers will be modified in place. No error is raised if the header is already absent.</p> required Source code in <code>t3api_utils/http/utils.py</code> <pre><code>def clear_bearer_token(*, client: Union[httpx.Client, httpx.AsyncClient]) -&gt; None:\n    \"\"\"Remove the ``Authorization`` header from a client, if present.\n\n    Args:\n        client: Sync or async ``httpx`` client whose headers will be\n            modified in place. No error is raised if the header is\n            already absent.\n    \"\"\"\n    if \"Authorization\" in client.headers:\n        del client.headers[\"Authorization\"]\n</code></pre>"},{"location":"reference/inspector/","title":"Inspector","text":""},{"location":"reference/inspector/#t3api_utils.inspector","title":"inspector","text":"<p>Collection inspector using Textual TUI.</p>"},{"location":"reference/inspector/#t3api_utils.inspector.CollectionInspectorApp","title":"CollectionInspectorApp","text":"<pre><code>CollectionInspectorApp(*, data: Sequence[Dict[str, Any]], collection_name: str = 'collection')\n</code></pre> <p>               Bases: <code>App[None]</code></p> <p>Textual app for inspecting collections.</p> <p>Initialize the collection inspector application.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[Dict[str, Any]]</code> <p>Sequence of JSON-serializable dictionaries to inspect.</p> required <code>collection_name</code> <code>str</code> <p>Display name for the collection shown in the title and status bar.</p> <code>'collection'</code> Source code in <code>t3api_utils/inspector/app.py</code> <pre><code>def __init__(self, *, data: Sequence[Dict[str, Any]], collection_name: str = \"collection\") -&gt; None:\n    \"\"\"Initialize the collection inspector application.\n\n    Args:\n        data: Sequence of JSON-serializable dictionaries to inspect.\n        collection_name: Display name for the collection shown in the\n            title and status bar.\n    \"\"\"\n    super().__init__()\n    self.original_data = list(data)\n    self.filtered_data = list(data)\n    self.current_index = 0\n    self.collection_name = collection_name\n    self.search_query = \"\"\n</code></pre>"},{"location":"reference/inspector/#t3api_utils.inspector.CollectionInspectorApp.compose","title":"compose","text":"<pre><code>compose() -&gt; ComposeResult\n</code></pre> <p>Create the app layout.</p> Source code in <code>t3api_utils/inspector/app.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"Create the app layout.\"\"\"\n    yield Header()\n\n    with Container(id=\"main-container\"):\n        yield StatusBar(self.collection_name, id=\"status\")\n\n        yield SearchBar(id=\"search-bar\")\n\n        with Container(id=\"content-area\"):\n            yield JSONViewer(id=\"json-viewer\")\n\n    yield Footer()\n</code></pre>"},{"location":"reference/inspector/#t3api_utils.inspector.CollectionInspectorApp.on_mount","title":"on_mount","text":"<pre><code>on_mount() -&gt; None\n</code></pre> <p>Initialize the app when mounted.</p> Source code in <code>t3api_utils/inspector/app.py</code> <pre><code>def on_mount(self) -&gt; None:\n    \"\"\"Initialize the app when mounted.\"\"\"\n    self.title = f\"Collection Inspector: {self.collection_name}\"\n    self.sub_title = f\"{len(self.filtered_data)} objects\"\n    self._update_display()\n</code></pre>"},{"location":"reference/inspector/#t3api_utils.inspector.CollectionInspectorApp.action_previous","title":"action_previous","text":"<pre><code>action_previous() -&gt; None\n</code></pre> <p>Navigate to previous object.</p> Source code in <code>t3api_utils/inspector/app.py</code> <pre><code>def action_previous(self) -&gt; None:\n    \"\"\"Navigate to previous object.\"\"\"\n    if self.filtered_data and self.current_index &gt; 0:\n        self.current_index -= 1\n        self._update_display()\n</code></pre>"},{"location":"reference/inspector/#t3api_utils.inspector.CollectionInspectorApp.action_next","title":"action_next","text":"<pre><code>action_next() -&gt; None\n</code></pre> <p>Navigate to next object.</p> Source code in <code>t3api_utils/inspector/app.py</code> <pre><code>def action_next(self) -&gt; None:\n    \"\"\"Navigate to next object.\"\"\"\n    if self.filtered_data and self.current_index &lt; len(self.filtered_data) - 1:\n        self.current_index += 1\n        self._update_display()\n</code></pre>"},{"location":"reference/inspector/#t3api_utils.inspector.CollectionInspectorApp.action_first","title":"action_first","text":"<pre><code>action_first() -&gt; None\n</code></pre> <p>Navigate to first object.</p> Source code in <code>t3api_utils/inspector/app.py</code> <pre><code>def action_first(self) -&gt; None:\n    \"\"\"Navigate to first object.\"\"\"\n    if self.filtered_data:\n        self.current_index = 0\n        self._update_display()\n</code></pre>"},{"location":"reference/inspector/#t3api_utils.inspector.CollectionInspectorApp.action_last","title":"action_last","text":"<pre><code>action_last() -&gt; None\n</code></pre> <p>Navigate to last object.</p> Source code in <code>t3api_utils/inspector/app.py</code> <pre><code>def action_last(self) -&gt; None:\n    \"\"\"Navigate to last object.\"\"\"\n    if self.filtered_data:\n        self.current_index = len(self.filtered_data) - 1\n        self._update_display()\n</code></pre>"},{"location":"reference/inspector/#t3api_utils.inspector.CollectionInspectorApp.action_clear","title":"action_clear","text":"<pre><code>action_clear() -&gt; None\n</code></pre> <p>Clear search filter.</p> Source code in <code>t3api_utils/inspector/app.py</code> <pre><code>def action_clear(self) -&gt; None:\n    \"\"\"Clear search filter.\"\"\"\n    search_input = self.query_one(\"#search-input\", Input)\n    search_input.value = \"\"\n    self._apply_search_filter(query=\"\")\n    status_bar = self.query_one(\"#status\", StatusBar)\n    status_bar.set_search(\"\", len(self.filtered_data))\n</code></pre>"},{"location":"reference/inspector/#t3api_utils.inspector.CollectionInspectorApp.action_focus_search","title":"action_focus_search","text":"<pre><code>action_focus_search() -&gt; None\n</code></pre> <p>Focus the search input.</p> Source code in <code>t3api_utils/inspector/app.py</code> <pre><code>def action_focus_search(self) -&gt; None:\n    \"\"\"Focus the search input.\"\"\"\n    search_input = self.query_one(\"#search-input\", Input)\n    search_input.focus()\n</code></pre>"},{"location":"reference/inspector/#t3api_utils.inspector.CollectionInspectorApp.action_help","title":"action_help","text":"<pre><code>action_help() -&gt; None\n</code></pre> <p>Show help information.</p> Source code in <code>t3api_utils/inspector/app.py</code> <pre><code>def action_help(self) -&gt; None:\n    \"\"\"Show help information.\"\"\"\n    help_text = \"\"\"\u2139 Navigation: \u2190/\u2192-Previous/Next Home/End-First/Last Ctrl+C-Clear /-Search ?-Help q/Esc-Quit. Use search bar to filter data.\"\"\"\n    self.notify(help_text, severity=\"information\")\n</code></pre>"},{"location":"reference/inspector/#t3api_utils.inspector.CollectionInspectorApp.on_search_changed","title":"on_search_changed","text":"<pre><code>on_search_changed(event: Changed) -&gt; None\n</code></pre> <p>Handle search input changes.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Changed</code> <p>The Input.Changed event containing the new search value.</p> required Source code in <code>t3api_utils/inspector/app.py</code> <pre><code>@on(Input.Changed, \"#search-input\")\ndef on_search_changed(self, event: Input.Changed) -&gt; None:\n    \"\"\"Handle search input changes.\n\n    Args:\n        event: The Input.Changed event containing the new search value.\n    \"\"\"\n    self._apply_search_filter(query=event.value)\n    status_bar = self.query_one(\"#status\", StatusBar)\n    status_bar.set_search(self.search_query, len(self.filtered_data))\n</code></pre>"},{"location":"reference/inspector/#t3api_utils.inspector.inspect_collection","title":"inspect_collection","text":"<pre><code>inspect_collection(*, data: Sequence[Dict[str, Any]], collection_name: str = 'collection') -&gt; None\n</code></pre> <p>Launch the Textual collection inspector.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[Dict[str, Any]]</code> <p>Sequence of JSON-serializable dictionaries to inspect. If empty, prints an info message and returns immediately.</p> required <code>collection_name</code> <code>str</code> <p>Display name for the collection shown in the title and status bar.</p> <code>'collection'</code> Source code in <code>t3api_utils/inspector/app.py</code> <pre><code>def inspect_collection(*, data: Sequence[Dict[str, Any]], collection_name: str = \"collection\") -&gt; None:\n    \"\"\"Launch the Textual collection inspector.\n\n    Args:\n        data: Sequence of JSON-serializable dictionaries to inspect.\n            If empty, prints an info message and returns immediately.\n        collection_name: Display name for the collection shown in the\n            title and status bar.\n    \"\"\"\n    if not data:\n        print_info(\"No data to inspect\")\n        return\n\n    app = CollectionInspectorApp(data=data, collection_name=collection_name)\n    app.run()\n</code></pre>"},{"location":"reference/logging/","title":"Logging","text":""},{"location":"reference/logging/#t3api_utils.logging","title":"logging","text":"<p>Logging configuration for t3api_utils.</p> <p>Sets up a Rich-based logging handler with colored output and rich tracebacks. Logging is configured automatically on import with INFO level; call :func:<code>setup_logging</code> to reconfigure with a different level.</p>"},{"location":"reference/logging/#t3api_utils.logging.setup_logging","title":"setup_logging","text":"<pre><code>setup_logging(level: int = logging.INFO) -&gt; None\n</code></pre> <p>Configure the root logger with a Rich handler.</p> <p>Replaces any existing handlers on the root logger with a single :class:<code>rich.logging.RichHandler</code> that renders rich tracebacks and supports Rich markup in log messages.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>Logging level threshold (default: <code>logging.INFO</code>).</p> <code>INFO</code> Source code in <code>t3api_utils/logging.py</code> <pre><code>def setup_logging(level: int = logging.INFO) -&gt; None:\n    \"\"\"Configure the root logger with a Rich handler.\n\n    Replaces any existing handlers on the root logger with a single\n    :class:`rich.logging.RichHandler` that renders rich tracebacks and\n    supports Rich markup in log messages.\n\n    Args:\n        level: Logging level threshold (default: ``logging.INFO``).\n    \"\"\"\n    logging.basicConfig(\n        level=level,\n        format=\"%(message)s\",\n        datefmt=\"[%X]\",\n        handlers=[RichHandler(rich_tracebacks=True, markup=True)]\n    )\n</code></pre>"},{"location":"reference/logging/#t3api_utils.logging.get_logger","title":"get_logger","text":"<pre><code>get_logger(name: str) -&gt; logging.Logger\n</code></pre> <p>Return a named logger.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Logger name, typically <code>__name__</code> of the calling module.</p> required <p>Returns:</p> Name Type Description <code>A</code> <code>Logger</code> <p>class:<code>logging.Logger</code> instance for the given name.</p> Source code in <code>t3api_utils/logging.py</code> <pre><code>def get_logger(name: str) -&gt; logging.Logger:\n    \"\"\"Return a named logger.\n\n    Args:\n        name: Logger name, typically ``__name__`` of the calling module.\n\n    Returns:\n        A :class:`logging.Logger` instance for the given name.\n    \"\"\"\n    return logging.getLogger(name)\n</code></pre>"},{"location":"reference/openapi/","title":"OpenAPI","text":""},{"location":"reference/openapi/#t3api_utils.openapi","title":"openapi","text":"<p>OpenAPI specification handling for T3 API endpoints.</p>"},{"location":"reference/openapi/#t3api_utils.openapi.CollectionEndpoint","title":"CollectionEndpoint","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type definition for a collection endpoint.</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>str</code> <p>The URL path of the endpoint (e.g. <code>/v2/packages/active</code>).</p> <code>method</code> <code>str</code> <p>The HTTP method in uppercase (e.g. <code>GET</code>).</p> <code>name</code> <code>str</code> <p>A user-friendly display name derived from the summary or path.</p> <code>category</code> <code>str</code> <p>The grouping category derived from tags or path segments.</p> <code>description</code> <code>str</code> <p>A human-readable description of what the endpoint returns.</p>"},{"location":"reference/openapi/#t3api_utils.openapi.fetch_openapi_spec","title":"fetch_openapi_spec","text":"<pre><code>fetch_openapi_spec() -&gt; Dict[str, Any]\n</code></pre> <p>Fetch the OpenAPI specification from the live T3 API.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The parsed OpenAPI specification as a dictionary.</p> <p>Raises:</p> Type Description <code>SystemExit</code> <p>If the API cannot be reached or returns invalid data.</p> Source code in <code>t3api_utils/openapi/spec_fetcher.py</code> <pre><code>def fetch_openapi_spec() -&gt; Dict[str, Any]:\n    \"\"\"\n    Fetch the OpenAPI specification from the live T3 API.\n\n    Returns:\n        The parsed OpenAPI specification as a dictionary.\n\n    Raises:\n        SystemExit: If the API cannot be reached or returns invalid data.\n    \"\"\"\n    api_host = config_manager.get_api_host()\n    spec_url = f\"{api_host}/v2/spec/openapi.json\"\n\n    console.print(f\"Fetching OpenAPI spec from {spec_url}...\")\n\n    try:\n        with httpx.Client(timeout=30.0) as client:\n            response = client.get(spec_url)\n            response.raise_for_status()\n\n        spec: Dict[str, Any] = response.json()\n        console.print(\"\u2713 OpenAPI spec fetched successfully\")\n        return spec\n\n    except httpx.HTTPError as e:\n        console.print(f\"\u2717 Failed to fetch OpenAPI spec: {e}\")\n        sys.exit(1)\n    except Exception as e:\n        console.print(f\"\u2717 Error parsing OpenAPI spec: {e}\")\n        sys.exit(1)\n</code></pre>"},{"location":"reference/openapi/#t3api_utils.openapi.get_collection_endpoints","title":"get_collection_endpoints","text":"<pre><code>get_collection_endpoints() -&gt; List[CollectionEndpoint]\n</code></pre> <p>Fetch and parse collection endpoints from the live API.</p> <p>Convenience function that fetches the OpenAPI spec and extracts all paginated collection endpoints in a single call.</p> <p>Returns:</p> Type Description <code>List[CollectionEndpoint]</code> <p>A list of <code>CollectionEndpoint</code> dicts describing each available</p> <code>List[CollectionEndpoint]</code> <p>collection.</p> <p>Raises:</p> Type Description <code>SystemExit</code> <p>If the API spec cannot be fetched or contains no collection endpoints.</p> Source code in <code>t3api_utils/openapi/spec_fetcher.py</code> <pre><code>def get_collection_endpoints() -&gt; List[CollectionEndpoint]:\n    \"\"\"Fetch and parse collection endpoints from the live API.\n\n    Convenience function that fetches the OpenAPI spec and extracts all\n    paginated collection endpoints in a single call.\n\n    Returns:\n        A list of ``CollectionEndpoint`` dicts describing each available\n        collection.\n\n    Raises:\n        SystemExit: If the API spec cannot be fetched or contains no\n            collection endpoints.\n    \"\"\"\n    spec = fetch_openapi_spec()\n    return parse_collection_endpoints(spec)\n</code></pre>"},{"location":"reference/openapi/#t3api_utils.openapi.pick_collection","title":"pick_collection","text":"<pre><code>pick_collection() -&gt; CollectionEndpoint\n</code></pre> <p>Interactive picker for selecting a collection endpoint.</p> <p>Returns:</p> Type Description <code>CollectionEndpoint</code> <p>The selected collection endpoint.</p> <p>Raises:</p> Type Description <code>SystemExit</code> <p>If user cancels or no endpoints are available.</p> Source code in <code>t3api_utils/openapi/collection_picker.py</code> <pre><code>def pick_collection() -&gt; CollectionEndpoint:\n    \"\"\"\n    Interactive picker for selecting a collection endpoint.\n\n    Returns:\n        The selected collection endpoint.\n\n    Raises:\n        SystemExit: If user cancels or no endpoints are available.\n    \"\"\"\n    endpoints = get_collection_endpoints()\n\n    # Group endpoints by category\n    categories = _group_by_category(endpoints)\n\n    if len(categories) == 1:\n        # If only one category, show endpoints directly\n        category_name = list(categories.keys())[0]\n        return _pick_from_category(category_name, categories[category_name])\n    else:\n        # Multiple categories, let user pick category first\n        selected_category = _pick_category(categories)\n        return _pick_from_category(selected_category, categories[selected_category])\n</code></pre>"},{"location":"reference/style/","title":"Style","text":""},{"location":"reference/style/#t3api_utils.style","title":"style","text":"<p>Purple-themed CLI styling for T3 API utilities.</p>"},{"location":"reference/style/#t3api_utils.style.error_style","title":"error_style  <code>module-attribute</code>","text":"<pre><code>error_style = Style(color='red', bold=True)\n</code></pre> <p>Bold red style for error messages and failures.</p>"},{"location":"reference/style/#t3api_utils.style.info_style","title":"info_style  <code>module-attribute</code>","text":"<pre><code>info_style = Style(color='blue', bold=True)\n</code></pre> <p>Bold blue style for informational messages and help text.</p>"},{"location":"reference/style/#t3api_utils.style.success_style","title":"success_style  <code>module-attribute</code>","text":"<pre><code>success_style = Style(color='green', bold=True)\n</code></pre> <p>Bold green style for success messages and completed actions.</p>"},{"location":"reference/style/#t3api_utils.style.warning_style","title":"warning_style  <code>module-attribute</code>","text":"<pre><code>warning_style = Style(color='yellow', bold=True)\n</code></pre> <p>Bold yellow style for warning messages and cautions.</p>"},{"location":"reference/style/#t3api_utils.style.progress_style","title":"progress_style  <code>module-attribute</code>","text":"<pre><code>progress_style = Style(color='magenta', bold=True)\n</code></pre> <p>Bold magenta style for progress indicators and status updates.</p>"},{"location":"reference/style/#t3api_utils.style.header_style","title":"header_style  <code>module-attribute</code>","text":"<pre><code>header_style = Style(color='magenta', bold=True)\n</code></pre> <p>Bold magenta style for main section headers and titles.</p>"},{"location":"reference/style/#t3api_utils.style.subheader_style","title":"subheader_style  <code>module-attribute</code>","text":"<pre><code>subheader_style = Style(color='bright_magenta', bold=True)\n</code></pre> <p>Bold bright magenta style for subsection headers.</p>"},{"location":"reference/style/#t3api_utils.style.menu_style","title":"menu_style  <code>module-attribute</code>","text":"<pre><code>menu_style = Style(color='magenta')\n</code></pre> <p>Magenta style for menu items and interactive selection elements.</p>"},{"location":"reference/style/#t3api_utils.style.file_path_style","title":"file_path_style  <code>module-attribute</code>","text":"<pre><code>file_path_style = Style(color='cyan')\n</code></pre> <p>Cyan style for file and directory paths.</p>"},{"location":"reference/style/#t3api_utils.style.technical_style","title":"technical_style  <code>module-attribute</code>","text":"<pre><code>technical_style = Style(color='white', dim=True)\n</code></pre> <p>Dim white style for technical details and secondary information.</p>"},{"location":"reference/style/#t3api_utils.style.data_style","title":"data_style  <code>module-attribute</code>","text":"<pre><code>data_style = Style(color='bright_white')\n</code></pre> <p>Bright white style for data values and code output.</p>"},{"location":"reference/style/#t3api_utils.style.primary_style","title":"primary_style  <code>module-attribute</code>","text":"<pre><code>primary_style = Style(color='magenta')\n</code></pre> <p>Primary magenta theme style for general branded elements.</p>"},{"location":"reference/style/#t3api_utils.style.accent_style","title":"accent_style  <code>module-attribute</code>","text":"<pre><code>accent_style = Style(color='bright_magenta')\n</code></pre> <p>Bright magenta accent style for highlights and emphasis.</p>"},{"location":"reference/style/#t3api_utils.style.muted_style","title":"muted_style  <code>module-attribute</code>","text":"<pre><code>muted_style = Style(color='magenta', dim=True)\n</code></pre> <p>Dim magenta style for subdued or secondary themed text.</p>"},{"location":"reference/style/#t3api_utils.style.print_success","title":"print_success","text":"<pre><code>print_success(message: str) -&gt; None\n</code></pre> <p>Print a success message with green checkmark.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Text to display after the green checkmark symbol.</p> required Source code in <code>t3api_utils/style/messages.py</code> <pre><code>def print_success(message: str) -&gt; None:\n    \"\"\"Print a success message with green checkmark.\n\n    Args:\n        message: Text to display after the green checkmark symbol.\n    \"\"\"\n    console.print(f\"{SUCCESS_SYMBOL} {message}\")\n</code></pre>"},{"location":"reference/style/#t3api_utils.style.print_error","title":"print_error","text":"<pre><code>print_error(message: str) -&gt; None\n</code></pre> <p>Print an error message with red X mark.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Text to display after the red X mark symbol.</p> required Source code in <code>t3api_utils/style/messages.py</code> <pre><code>def print_error(message: str) -&gt; None:\n    \"\"\"Print an error message with red X mark.\n\n    Args:\n        message: Text to display after the red X mark symbol.\n    \"\"\"\n    console.print(f\"{ERROR_SYMBOL} {message}\")\n</code></pre>"},{"location":"reference/style/#t3api_utils.style.print_warning","title":"print_warning","text":"<pre><code>print_warning(message: str) -&gt; None\n</code></pre> <p>Print a warning message with yellow warning symbol.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Text to display after the yellow warning symbol.</p> required Source code in <code>t3api_utils/style/messages.py</code> <pre><code>def print_warning(message: str) -&gt; None:\n    \"\"\"Print a warning message with yellow warning symbol.\n\n    Args:\n        message: Text to display after the yellow warning symbol.\n    \"\"\"\n    console.print(f\"{WARNING_SYMBOL} {message}\")\n</code></pre>"},{"location":"reference/style/#t3api_utils.style.print_info","title":"print_info","text":"<pre><code>print_info(message: str) -&gt; None\n</code></pre> <p>Print an info message with blue info symbol.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Text to display after the blue info symbol.</p> required Source code in <code>t3api_utils/style/messages.py</code> <pre><code>def print_info(message: str) -&gt; None:\n    \"\"\"Print an info message with blue info symbol.\n\n    Args:\n        message: Text to display after the blue info symbol.\n    \"\"\"\n    console.print(f\"{INFO_SYMBOL} {message}\")\n</code></pre>"},{"location":"reference/style/#t3api_utils.style.print_progress","title":"print_progress","text":"<pre><code>print_progress(message: str) -&gt; None\n</code></pre> <p>Print a progress/status message with purple dots.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Status text to display after the purple dots symbol.</p> required Source code in <code>t3api_utils/style/messages.py</code> <pre><code>def print_progress(message: str) -&gt; None:\n    \"\"\"Print a progress/status message with purple dots.\n\n    Args:\n        message: Status text to display after the purple dots symbol.\n    \"\"\"\n    console.print(f\"{PROGRESS_SYMBOL} {message}\")\n</code></pre>"},{"location":"reference/style/#t3api_utils.style.print_header","title":"print_header","text":"<pre><code>print_header(title: str) -&gt; None\n</code></pre> <p>Print a main header with decorative purple borders.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Header text displayed between the decorative border symbols.</p> required Source code in <code>t3api_utils/style/messages.py</code> <pre><code>def print_header(title: str) -&gt; None:\n    \"\"\"Print a main header with decorative purple borders.\n\n    Args:\n        title: Header text displayed between the decorative border symbols.\n    \"\"\"\n    console.print(f\"{MAIN_HEADER_PREFIX} {title} {MAIN_HEADER_SUFFIX}\")\n</code></pre>"},{"location":"reference/style/#t3api_utils.style.print_subheader","title":"print_subheader","text":"<pre><code>print_subheader(title: str) -&gt; None\n</code></pre> <p>Print a section subheader with decorative purple borders.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Subheader text displayed between the decorative border symbols.</p> required Source code in <code>t3api_utils/style/messages.py</code> <pre><code>def print_subheader(title: str) -&gt; None:\n    \"\"\"Print a section subheader with decorative purple borders.\n\n    Args:\n        title: Subheader text displayed between the decorative border symbols.\n    \"\"\"\n    console.print(f\"{SUB_HEADER_PREFIX} {title} {SUB_HEADER_SUFFIX}\")\n</code></pre>"},{"location":"reference/style/#t3api_utils.style.print_menu_item","title":"print_menu_item","text":"<pre><code>print_menu_item(number: int, text: str) -&gt; None\n</code></pre> <p>Print a numbered menu item with purple styling.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int</code> <p>Menu item number displayed as the selection index.</p> required <code>text</code> <code>str</code> <p>Description text displayed after the number.</p> required Source code in <code>t3api_utils/style/messages.py</code> <pre><code>def print_menu_item(number: int, text: str) -&gt; None:\n    \"\"\"Print a numbered menu item with purple styling.\n\n    Args:\n        number: Menu item number displayed as the selection index.\n        text: Description text displayed after the number.\n    \"\"\"\n    formatted_number = MENU_NUMBER.format(number=number)\n    console.print(f\"  {formatted_number} {text}\")\n</code></pre>"},{"location":"reference/style/#t3api_utils.style.print_file_path","title":"print_file_path","text":"<pre><code>print_file_path(path: Any) -&gt; None\n</code></pre> <p>Print a file path with cyan highlighting.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Any</code> <p>File or directory path to display with cyan styling.</p> required Source code in <code>t3api_utils/style/messages.py</code> <pre><code>def print_file_path(path: Any) -&gt; None:\n    \"\"\"Print a file path with cyan highlighting.\n\n    Args:\n        path: File or directory path to display with cyan styling.\n    \"\"\"\n    console.print(f\"[cyan]{path}[/cyan]\")\n</code></pre>"},{"location":"reference/style/#t3api_utils.style.print_technical","title":"print_technical","text":"<pre><code>print_technical(info: str) -&gt; None\n</code></pre> <p>Print technical information in dim text.</p> <p>Parameters:</p> Name Type Description Default <code>info</code> <code>str</code> <p>Technical detail text rendered in dim styling.</p> required Source code in <code>t3api_utils/style/messages.py</code> <pre><code>def print_technical(info: str) -&gt; None:\n    \"\"\"Print technical information in dim text.\n\n    Args:\n        info: Technical detail text rendered in dim styling.\n    \"\"\"\n    console.print(f\"[dim]{info}[/dim]\")\n</code></pre>"},{"location":"reference/style/#t3api_utils.style.print_data","title":"print_data","text":"<pre><code>print_data(data: str) -&gt; None\n</code></pre> <p>Print data/code in bright white.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>Data or code content displayed in bright white styling.</p> required Source code in <code>t3api_utils/style/messages.py</code> <pre><code>def print_data(data: str) -&gt; None:\n    \"\"\"Print data/code in bright white.\n\n    Args:\n        data: Data or code content displayed in bright white styling.\n    \"\"\"\n    console.print(f\"[bright_white]{data}[/bright_white]\")\n</code></pre>"},{"location":"reference/style/#t3api_utils.style.print_labeled_info","title":"print_labeled_info","text":"<pre><code>print_labeled_info(label: str, value: Any) -&gt; None\n</code></pre> <p>Print labeled information with purple label and white value.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Descriptive label rendered in magenta, followed by a colon.</p> required <code>value</code> <code>Any</code> <p>Associated value rendered in bright white after the label.</p> required Source code in <code>t3api_utils/style/messages.py</code> <pre><code>def print_labeled_info(label: str, value: Any) -&gt; None:\n    \"\"\"Print labeled information with purple label and white value.\n\n    Args:\n        label: Descriptive label rendered in magenta, followed by a colon.\n        value: Associated value rendered in bright white after the label.\n    \"\"\"\n    console.print(f\"[magenta]{label}:[/magenta] [bright_white]{value}[/bright_white]\")\n</code></pre>"},{"location":"reference/style/#t3api_utils.style.print_state_info","title":"print_state_info","text":"<pre><code>print_state_info(state_items: list[str]) -&gt; None\n</code></pre> <p>Print current state information with purple styling.</p> <p>Parameters:</p> Name Type Description Default <code>state_items</code> <code>list[str]</code> <p>List of state descriptor strings joined with pipe separators. No output is produced if the list is empty.</p> required Source code in <code>t3api_utils/style/messages.py</code> <pre><code>def print_state_info(state_items: list[str]) -&gt; None:\n    \"\"\"Print current state information with purple styling.\n\n    Args:\n        state_items: List of state descriptor strings joined with pipe\n            separators. No output is produced if the list is empty.\n    \"\"\"\n    if state_items:\n        state_text = \" | \".join(state_items)\n        console.print(f\"[dim]Current state:[/dim] [magenta]{state_text}[/magenta]\")\n</code></pre>"}]}